<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>client</title>
    <script src="/vendor/socket.io.js"></script>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <!-- ================= VIDEO ================= -->
    <div id="videoContainer">
      <div id="viewInfo">âœ</div>
      <video id="gameVideo" controls playsinline></video>
      <video id="libraryVideo" controls style="display: none">
        <track id="libraryVideoTrack" kind="subtitles" default />
      </video>
      <div id="subtitleOverlayLocal" class="subtitleOverlay"></div>
      <div
        id="subtitleOverlayRemote"
        class="subtitleOverlay"
        style="display: none"
      ></div>
    </div>

    <!-- ================= PLAYER VIEW ================= -->
    <div id="playerView" class="viewContainer">
      <div id="subtitlesList"></div>
    </div>

    <!-- ================= REMOTE VIEW ================= -->
    <div
      id="remoteView"
      class="viewContainer"
      style="display: none; gap: 16px; max-width: 100vw"
    >
      <div style="display: flex; width: 100%; height: 80%">
        <!-- Colonne gauche -->
        <div
          style="
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 0;
          "
        >
          <div>
            <span id="clipLabel" style="cursor: inherit">ğŸ“ğŸ“—</span>
            <select id="clipSelect"></select>
          </div>
          <div
            id="savesList"
            style="display: block; width: 100%; overflow-y: auto"
          ></div>
        </div>

        <!-- Colonne droite -->
        <div
          style="
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 70%;
          "
        >
          <div style="display: flex; justify-content: space-between">
            <button id="previousTimeButton">âª</button>
            <button id="videoStateButton">ğŸ”„</button>
            <button id="nextTimeButton">â©</button>
            <button id="stopButton">â¹ï¸</button>
            <input
              id="saveNameInput"
              placeholder="Nom ğŸ“„"
              style="display: none; max-width: 50%"
            />
            <button id="saveButton" disabled style="display: none">
              ğŸ’¾ğŸ“„â†’ğŸ“ğŸ“—
            </button>
          </div>
          <div id=""></div>
          <div
            id="playersList"
            style="display: block; width: 100%; overflow-y: auto"
          ></div>
        </div>
        <!-- RemoteView Timeline Container -->
      </div>

      <div
        id="timelineContainer"
        style="
          display: flex;
          overflow-x: auto;
          gap: 4px;
          padding: 4px;
          border: 1px solid #454545;
          height: 20%;
          background-color: #d9d9d9;
        "
      ></div>
    </div>

    <!-- ================= LIBRARY VIEW ================= -->
    <div id="libraryView" class="viewContainer" style="display: none">
      <div class="libraryLayout">
        <span id="libraryLabel" style="cursor: inherit">ğŸ“šğŸï¸ğŸ“„</span>
        <select
          id="librarySelect"
          style="font-size: 30px; max-width: 100%"
        ></select>

        <div class="libraryEditor">
          <div>
            <label for="startClipInput">â²</label>
            <input
              id="startClipInput"
              type="text"
              required
              placeholder="00:00:00"
              pattern="^([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)$"
              title="Format attendu : hh:mm:ss"
            />
          </div>

          <div>
            <label for="endClipInput">â²</label>
            <input
              id="endClipInput"
              type="text"
              required
              placeholder="00:00:00"
              pattern="^([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)$"
              title="Format attendu : hh:mm:ss"
            />
          </div>

          <input
            id="clipName"
            required
            placeholder="Nom ğŸ“ğŸ“—"
            pattern=".*\S.*"
            title="Le nom du clip ne peut pas Ãªtre vide"
          />
          <button id="createClip">ğŸ“ğŸ“—â†’âš™ï¸ğŸ¤</button>
        </div>

        <div
          id="libraryClipSelectContainer"
          style="display: none; align-items: center; gap: 4px"
        >
          <select id="libraryClipSelect"></select>
          <button id="deleteClipButton" style="display: none">âŒğŸ“ğŸ“—</button>
        </div>
      </div>
    </div>

    <!-- ================= FOOTER ================= -->
    <div id="subtitleForm">
      <div class="row">
        <div id="viewActionMenu" class="action-menu">
          <button class="action-menu-toggle">âš™ï¸</button>

          <div class="action-menu-panel">
            <button class="action-menu-item" data-action="libraryView">
              ğŸ“š
            </button>
            <button class="action-menu-item" data-action="remoteView">
              ğŸ¤
            </button>
            <button class="action-menu-item" data-action="playerView">
              âœ
            </button>
          </div>
        </div>

        <span style="background: #489dce" id="playerName"></span>

        <button id="submitButton">ğŸ“„</button>

        <div id="emoticonActionMenu" style="display: none" class="action-menu">
          <button class="action-menu-toggle">ğŸ’¬</button>

          <div class="action-menu-panel">
            <!-- Colonne 1 : Confusion / neutre / gÃªnÃ© -->
            <button class="action-menu-item" data-action="emoticon">ğŸ˜•</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¬</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ¤¨</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¶</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ™„</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜®â€ğŸ’¨</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜³</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜</button>

            <!-- Colonne 2 : Positif / joyeux -->
            <button class="action-menu-item" data-action="emoticon">ğŸ™‚</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜ƒ</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜‚</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜„</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜Š</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ¥³</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜º</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¸</button>

            <!-- Colonne 3 : NÃ©gatif / critique / dÃ©sapprobation -->
            <button class="action-menu-item" data-action="emoticon">â—</button>
            <button class="action-menu-item" data-action="emoticon">âŒ</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ‘</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¡</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜ </button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜°</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¢</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜Ÿ</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¥</button>

            <!-- Colonne 4 : Surprise / choc / Ã©tonnement -->
            <button class="action-menu-item" data-action="emoticon">ğŸ˜®</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜²</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜±</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ¤¯</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜§</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¨</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¦</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜µ</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¶â€ğŸŒ«ï¸</button>

            <!-- Colonne 5 : Amour / affection / positif -->
            <button class="action-menu-item" data-action="emoticon">ğŸ˜</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ¥°</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜˜</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜»</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ’–</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ’˜</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ’</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ’</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ’—</button>

            <!-- Colonne 6 : Blague / drÃ´le / espiÃ¨gle -->
            <button class="action-menu-item" data-action="emoticon">ğŸ˜œ</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ¤ª</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜›</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ¤­</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¼</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¹</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜»</button>
          </div>
        </div>

        <button id="renderButton" disabled style="display: none">ğŸ“½ï¸ğŸ•”</button>
        <button id="goToRender" disabled style="display: none">ğŸï¸</button>
      </div>
    </div>

    <script>
      async function main() {
        /* ================= DOM ================= */
        const viewInfo = document.getElementById("viewInfo");
        const gameVideo = document.getElementById("gameVideo");
        const libraryVideo = document.getElementById("libraryVideo");
        const libraryVideoTrack = document.getElementById("libraryVideoTrack");
        const subtitleOverlayLocal = document.getElementById(
          "subtitleOverlayLocal"
        );

        const videoContainer = document.getElementById("videoContainer");
        const subtitleOverlayRemote = document.getElementById(
          "subtitleOverlayRemote"
        );
        const subtitlesList = document.getElementById("subtitlesList");

        const subtitleForm = document.getElementById("subtitleForm");
        const submitButton = document.getElementById("submitButton");

        const saveButton = document.getElementById("saveButton");
        const saveNameInput = document.getElementById("saveNameInput");

        const videoStateButton = document.getElementById("videoStateButton");
        const stopButton = document.getElementById("stopButton");
        const previousTimeButton =
          document.getElementById("previousTimeButton");
        const nextTimeButton = document.getElementById("nextTimeButton");

        const emoticonActionMenu =
          document.getElementById("emoticonActionMenu");

        const playerNameSpan = document.getElementById("playerName");

        const playerView = document.getElementById("playerView");
        const remoteView = document.getElementById("remoteView");
        const libraryView = document.getElementById("libraryView");
        const clipLabel = document.getElementById("clipLabel");
        const librarySelect = document.getElementById("librarySelect");
        const libraryClipSelect = document.getElementById("libraryClipSelect");
        const deleteClipButton = document.getElementById("deleteClipButton");

        const renderButton = document.getElementById("renderButton");
        const goToRender = document.getElementById("goToRender");

        const libraryClipSelectContainer = document.getElementById(
          "libraryClipSelectContainer"
        );

        const clipSelect = document.getElementById("clipSelect");
        const playersList = document.getElementById("playersList");
        const savesList = document.getElementById("savesList");

        /* ================= STATE ================= */
        let videosById = {};
        let libraryVideosById = {};
        let currentViewId = "playerView";
        let playerSubtitles = [];
        let currentVideoId = null;
        let isEditingSubtitle = false;
        let isRemoteVisible = false;
        let applyingRemoteChange = false;
        let lastAppliedVideoState = { id: null, time: null };
        let lastGameState = null;

        function savesKey(videoId) {
          return `savedSubs_${videoId}`;
        }

        function isMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        }

        /* ================= PLAYER NAME ================= */
        let playerName = localStorage.getItem("playerName");
        if (!playerName) {
          playerName = prompt(
            "Quel est ton pseudo ?",
            "Joueur " + Math.floor(Math.random() * 1000)
          );
          localStorage.setItem("playerName", playerName);
        }
        playerNameSpan.textContent = "ğŸ¤– " + playerName;

        /* ================= CONFIG ================= */
        const cfg = await fetch("/config.json").then((r) => r.json());
        videosById = Object.fromEntries(cfg.clips.map((v) => [v.id, v]));
        libraryVideosById = Object.fromEntries(
          cfg.library_videos.map((v) => [v.id, v])
        );

        /* ================= SOCKET ================= */
        const socket = io({ reconnection: true, timeout: 20000 });
        socket.on("connect", () =>
          socket.emit("register", { role: "player", playerName })
        );

        socket.on("reload", () => location.reload());

        /* ================= INIT DISPLAY ================= */
        gameVideo.style.display = "block";
        subtitleOverlayLocal.style.display = "block";
        subtitleOverlayRemote.style.display = "none";
        playerView.style.display = "block";
        remoteView.style.display = "none";

        const submitSubtitles = () => {
          if (
            playerSubtitles.length === 0 ||
            playerSubtitles.every((s) => !s.text || s.text === "")
          )
            return false;

          socket.emit(
            "submitSubtitles",
            playerSubtitles.map((s) => ({
              start: s.start,
              end: s.end,
              text: s.text || "",
              placeholder: s.placeholder,
            }))
          );

          return true;
        };

        /* ================= LOCAL VIDEO ================= */
        function loadLocalVideo(state, videoCfg) {
          gameVideo.src = videoCfg.path;
          gameVideo.load();
          playerSubtitles = null;
        }

        function initPlayerSubtitles(state, videoCfg) {
          for (let key in state.players) {
            if (playerName === state.players[key].name) {
              playerSubtitles = state.players[key].subtitles;
              break;
            }
          }

          if (!playerSubtitles) return; // player is not in the state yet

          const cached = localStorage.getItem(`subs_${videoCfg.id}`);
          if (cached) {
            const subtitlesCached = JSON.parse(cached);
            playerSubtitles = playerSubtitles.map((s, index) => {
              return {
                ...s,
                text: subtitlesCached[index] ? subtitlesCached[index].text : "",
              };
            });
          }

          localStorage.setItem(
            `subs_${currentVideoId}`,
            JSON.stringify(playerSubtitles.map((s) => ({ text: s.text })))
          );
          cleanupOtherCaches(videoCfg.id);
          renderSubtitles();
        }

        function cleanupOtherCaches(id) {
          Object.keys(localStorage)
            .filter((k) => k.startsWith("subs_") && k !== `subs_${id}`)
            .forEach((k) => localStorage.removeItem(k));
        }

        const stripHours = (t) => {
          const [, mm, rest] = t.split(":");
          return `${mm}:${rest}`;
        };

        function renderSubtitles() {
          subtitlesList.innerHTML = playerSubtitles
            .map(
              (s, i) => `
                                <div class="subtitleItem" id="sub-${i}">
                                    <button class="seekButton" onclick="seekTo(${
                                      s.start
                                    })">â–¶</button>
                                 <div class="subtitleText">
                                    <span class="subtitleTime">${stripHours(
                                      fmt(s.start)
                                    )} - ${stripHours(fmt(s.end))}</span>
                                  <input class="subtitleInput"
                                    value="${s.text ? s.text : ""}"
                                    placeholder="${s.placeholder}"
                                    onfocus="focusSubtitle(${i})"
                                    onblur="stopEditing()"
                                    oninput="updateSubtitle(${i}, this.value)">
                                    </div>
                                </div>`
            )
            .join("");
        }

        function renderSaves() {
          const state = lastGameState;
          if (!state?.video?.id) {
            savesList.innerHTML = "";
            return;
          }

          const saves =
            (state.clipSaves && state.clipSaves[state.video.id]) || [];
          if (!saves.length) {
            savesList.innerHTML = `
            <em>Aucune sauvegarde de sous-titres ğŸ“„</em>`;
            return;
          }

          savesList.innerHTML = saves
            .map((s, index) => {
              return `
        <div class="saveItem" style="display:flex; justify-content:space-between; align-items:center;">
          <span>ğŸ“„${s.name}</span>
          <div>
            <button onclick="loadSave(${index})">âœ</button>
            <button onclick="deleteSave(${index})">âŒ</button>
            <button onclick="selectClipToInsert('${state.video.id}', ${index})">â•â†’ğŸ•”</button>
          </div>
        </div>
      `;
            })
            .join("");
        }

        const renderLocalOverlay = () => {
          if (currentViewId !== "playerView") return;
          const t = gameVideo.currentTime;
          const active = playerSubtitles.find(
            (s) => t >= s.start && t <= s.end
          );

          // Overlay local
          subtitlesList
            .querySelectorAll(".subtitleItem")
            .forEach((el, i) =>
              el.classList.toggle("active", playerSubtitles[i] === active)
            );

          if (active && !isRemoteVisible) {
            subtitleOverlayLocal.textContent =
              active.text || active.placeholder;
            subtitleOverlayLocal.style.display = "block";
            if (!isEditingSubtitle)
              scrollToSub(playerSubtitles.indexOf(active));
          } else subtitleOverlayLocal.style.display = "none";
        };

        const updateHeight = () => {
          const newHeight = window.innerHeight;

          const videoHeight = videoContainer.getBoundingClientRect().height;
          const subtitleFormHeight =
            subtitleForm.getBoundingClientRect().height;
          const viewHeight = newHeight - videoHeight - subtitleFormHeight;
          playerView.style.height = `${viewHeight}px`;
          remoteView.style.height = `${viewHeight}px`;
        };

        const displayView = (id) => {
          if (id === currentViewId) return;

          currentViewId = id;

          viewInfo.textContent =
            id === "playerView" ? "âœ" : id === "remoteView" ? "ğŸ¤" : "ğŸ“š";

          localStorage.setItem("currentViewId", currentViewId);
          playerView.style.display = id === "playerView" ? "block" : "none";
          remoteView.style.display = id === "remoteView" ? "block" : "none";
          libraryView.style.display = id === "libraryView" ? "block" : "none";

          gameVideo.style.display =
            id === "playerView" || id === "remoteView" ? "block" : "none";
          libraryVideo.style.display = id === "libraryView" ? "block" : "none";

          if (id === "playerView" || id === "remoteView") {
            socket.emit("needGameState");
          } else {
            if (Object.values(libraryVideosById).length > 0) {
              libraryVideo.src = libraryVideosById[librarySelect.value].path;
              libraryVideoTrack.src = libraryVideosById[
                librarySelect.value
              ].srt.replace(/\.srt$/i, ".vtt");
            }
          }

          libraryClipSelectContainer.style.display =
            id === "libraryView" ? "inline-flex" : "none";

          deleteClipButton.style.display =
            id === "libraryView" ? "block" : "none";

          submitButton.style.display = id === "playerView" ? "block" : "none";

          renderButton.style.display = id === "remoteView" ? "block" : "none";
          goToRender.style.display = id === "remoteView" ? "block" : "none";

          isRemoteVisible = id === "remoteView";

          subtitleOverlayLocal.style.display =
            id === "playerView" ? "block" : "none";
          subtitleOverlayRemote.style.display = isRemoteVisible
            ? "block"
            : "none";

          saveButton.style.display = !isRemoteVisible ? "none" : "block";
          saveNameInput.style.display = !isRemoteVisible ? "none" : "block";
          emoticonActionMenu.style.display = isRemoteVisible ? "block" : "none";
          gameVideo.controls = !isRemoteVisible;

          gameVideo.pause();
          libraryVideo.pause();

          requestAnimationFrame(() => updateHeight());
        };

        let resizeTimeout;
        let lastHeight = window.innerHeight;
        let currentSubtitleIndex = null;

        window.addEventListener("resize", () => {
          const newHeight = window.innerHeight;

          updateHeight();

          clearTimeout(resizeTimeout);

          // On attend que la hauteur se stabilise
          resizeTimeout = setTimeout(() => {
            if (newHeight === lastHeight) {
              // Ici tu peux scroll vers la subtitle active
              scrollToSub(currentSubtitleIndex, 400, false);
            } else if (newHeight > lastHeight) {
              showAllSubtitles();
            }
            lastHeight = newHeight;
          }, 50); // 50ms aprÃ¨s le dernier resize, la hauteur est stabilisÃ©e
        });

        window.loadSave = (index) => {
          if (!lastGameState?.video?.id) return;

          const saves =
            (lastGameState.clipSaves &&
              lastGameState.clipSaves[lastGameState.video.id]) ||
            [];
          const save = saves[index];
          if (!save) return;

          // âš¡ Copier les sous-titres dans playerSubtitles
          playerSubtitles = structuredClone(save.subtitles);

          // RÃ©hydrater complÃ¨tement lâ€™UI
          renderSubtitles();

          // Forcer recalcul overlay / scroll
          gameVideo.dispatchEvent(new Event("timeupdate"));

          // Afficher playerView
          displayView("playerView");
        };

        window.deleteSave = (index) => {
          if (!lastGameState?.video?.id) return;

          const videoId = lastGameState.video.id;

          // ğŸ”¹ Demande serveur pour supprimer le save
          socket.emit("deleteClipSave", { videoId, index });
        };

        window.focusSubtitle = (i) => {
          isEditingSubtitle = true;
          gameVideo.pause();
          seekTo(playerSubtitles[i].start);

          if (!isMobile()) return;
          hideOtherSubtitles(i);
          currentSubtitleIndex = i;
        };

        window.stopEditing = () => {
          isEditingSubtitle = false;
          showAllSubtitles();
        };

        function hideOtherSubtitles(i) {
          document
            .querySelectorAll(".subtitleItem")
            .forEach(
              (el, j) => (el.style.display = j >= i - 1 ? "flex" : "none")
            );
        }

        function showAllSubtitles() {
          document
            .querySelectorAll(".subtitleItem")
            .forEach((el) => (el.style.display = "flex"));

          if (currentSubtitleIndex !== null) scrollToSub(currentSubtitleIndex);
        }

        let scrollTimeout = null;

        function scrollToSub(i, duration = 0, smooth = true) {
          const target = document.getElementById(`sub-${i}`);
          if (!target) return;

          // Annule un scroll prÃ©cÃ©dent si actif
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
            scrollTimeout = null;
          }

          const doScroll = () => {
            target.scrollIntoView({
              behavior: smooth ? "smooth" : "instant",
              block: "end",
            });
          };

          if (duration === 0) {
            doScroll();
          } else {
            scrollTimeout = setTimeout(() => {
              doScroll();
              scrollTimeout = null;
            }, duration);
          }
        }

        window.updateSubtitle = (i, text) => {
          playerSubtitles[i].text = text;
          localStorage.setItem(
            `subs_${currentVideoId}`,
            JSON.stringify(playerSubtitles)
          );
          renderLocalOverlay();
        };

        window.seekTo = (t) => {
          gameVideo.currentTime = Math.min(gameVideo.duration, t + 0.01);
        };

        gameVideo.addEventListener("timeupdate", () => {
          // Overlay remote
          if (isRemoteVisible) renderRemoteSubtitles();
          else renderLocalOverlay();
        });

        submitButton.onclick = () => {
          const success = submitSubtitles();
          if (success && !isRemoteVisible) {
            displayView("remoteView");
          }

          submitButton.textContent = success ? "âœ…" : "âŒ";
          setTimeout(() => (submitButton.textContent = "ğŸ“„"), 1000);
        };

        stopButton.onclick = () => {
          socket.emit("stopButtonClicked");
        };

        previousTimeButton.onclick = () => {
          socket.emit("previousTimeButtonClicked");
        };

        nextTimeButton.onclick = () => {
          socket.emit("nextTimeButtonClicked");
        };

        const updateVideoState = async (videoState) => {
          if (videoState.playing) {
            gameVideo.currentTime = videoState.time;
            try {
              await gameVideo.play();
            } catch {}
            videoStateButton.textContent = "â¸ï¸";
          } else {
            gameVideo.pause();
            videoStateButton.textContent = "â–¶ï¸";
          }
          console.log("update gameVideo from state");
        };

        /* ================= REMOTE VIDEO ================= */
        async function applyRemoteVideoState(videoState, videoCfg) {
          if (lastAppliedVideoState.id !== videoState.id) {
            applyingRemoteChange = true;

            videoStateButton.textContent = "ğŸ”„";
            lastAppliedVideoState.id = videoState.id;

            if (gameVideo.src !== videoCfg.path) {
              gameVideo.src = videoCfg.path;
            }

            await new Promise((resolve) => {
              if (gameVideo.readyState >= 2) {
                // dÃ©jÃ  prÃªt
                resolve();
              } else {
                gameVideo.addEventListener("loadedmetadata", resolve, {
                  once: true,
                });
              }
            });

            await updateVideoState(videoState);

            applyingRemoteChange = false;
          }

          // Gestion playerSelected
          if (videoState.playerSelected) {
            applyingRemoteChange = true;
            gameVideo.currentTime = 0;
            await updateVideoState(videoState);

            applyingRemoteChange = false;
          }

          // Pause / resume
          if (videoState.paused) {
            applyingRemoteChange = true;
            await updateVideoState(videoState);

            applyingRemoteChange = false; // TODO remove this flag ?
          }

          // Sync temps
          if (Math.abs(gameVideo.currentTime - videoState.time) > 1) {
            applyingRemoteChange = true;
            gameVideo.currentTime = videoState.time;
            applyingRemoteChange = false;
          }

          lastAppliedVideoState = { ...videoState };
        }

        function renderRemoteSubtitles() {
          if (!lastGameState) return;
          const t = gameVideo.currentTime;
          const {
            selectedPlayerId,
            players,
            video: videoState,
          } = lastGameState;
          const videoCfg = videosById[videoState.id];
          let activeSub = null;
          if (selectedPlayerId && players[selectedPlayerId])
            activeSub = players[selectedPlayerId].subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
          if (!activeSub && videoCfg?.subtitles) {
            const placeholder = videoCfg.subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
            if (placeholder) activeSub = { text: placeholder.placeholder };
          }
          if (activeSub) {
            subtitleOverlayRemote.textContent = activeSub.text
              ? activeSub.text
              : activeSub.placeholder;
            subtitleOverlayRemote.style.display = "block";
          } else subtitleOverlayRemote.style.display = "none";
        }

        /* ================= TIMELINE ================= */

        let selectedClipToInsert = null; // clip choisi pour insertion
        let timelineClips = []; // clips actuellement dans la timeline

        // SÃ©lection d'un clip depuis la liste des saves
        window.selectClipToInsert = function selectClipToInsert(
          videoId,
          saveIndex
        ) {
          const saves = lastGameState.clipSaves?.[videoId] || [];
          const clip = saves[saveIndex];
          if (!clip) return;
          selectedClipToInsert = { videoId, ...clip, index: saveIndex };
          renderTimeline();
        };

        // Render timeline avec slots â• uniquement si un clip est sÃ©lectionnÃ©
        function renderTimeline() {
          const container = document.getElementById("timelineContainer");
          container.innerHTML = "";

          const labelStart = document.createElement("div");
          labelStart.textContent = "ğŸ•”";
          labelStart.style.flex = "0 0 auto"; // ne pas Ã©tirer
          labelStart.style.padding = "4px";
          labelStart.style.border = "1px solid black";
          container.appendChild(labelStart);

          const showSlots = !!selectedClipToInsert;

          if (showSlots) addSlot(0);

          timelineClips.forEach((clip, i) => {
            const div = document.createElement("div");
            div.className = "timelineClipItem";
            div.style.flex = "0 0 auto"; // taille fixe selon contenu
            div.style.display = "flex";
            div.style.alignItems = "center";
            div.style.border = "1px solid black";
            div.style.padding = "2px 4px";
            div.style.marginRight = "4px";

            div.style.overflow = "hidden"; // empÃªche le texte de dÃ©passer
            div.style.textOverflow = "ellipsis";
            div.style.whiteSpace = "nowrap";

            const label = document.createElement("span");
            label.textContent = clip.videoId + " - " + clip.name;
            label.style.flex = "1"; // prend tout l'espace disponible
            div.appendChild(label);

            const delBtn = document.createElement("button");
            delBtn.textContent = "âŒğŸ•”";
            delBtn.style.flex = "0 0 auto"; // ne pas Ã©tirer
            delBtn.onclick = (e) => {
              e.stopPropagation();
              timelineClips.splice(i, 1);
              renderTimeline();
              socket.emit("updateTimeline", timelineClips);
            };
            div.appendChild(delBtn);

            container.appendChild(div);

            if (showSlots) addSlot(i + 1);
          });

          // helper pour crÃ©er un slot
          function addSlot(position) {
            const slot = document.createElement("button");
            slot.textContent = "â•";
            slot.onclick = () => {
              if (!selectedClipToInsert) return;
              timelineClips.splice(position, 0, { ...selectedClipToInsert });
              selectedClipToInsert = null; // dÃ©sÃ©lection
              renderTimeline();
              socket.emit("updateTimeline", timelineClips);
            };
            container.appendChild(slot);
          }
        }

        function insertClip(index) {
          if (!selectedClipToInsert) return;

          // timelineClips est ton tableau global de la timeline
          timelineClips.splice(index + 1, 0, { ...selectedClipToInsert });
          selectedClipToInsert = null; // dÃ©sÃ©lection
          renderTimeline();
          socket.emit("updateTimeline", timelineClips);
        }

        submitButton.addEventListener("animationend", () => {
          submitButton.textContent = "ğŸ“„";
        });

        /* ================= SOCKET GAMESTATE ================= */
        let currentEmoticons = {};
        const receivedSound = new Audio("/sounds/notif.wav");
        receivedSound.volume = 0.6;

        socket.on("gameState", async (state) => {
          lastGameState = state;

          const videoCfg = videosById[state.video.id];

          if (currentVideoId !== state.video.id) {
            currentVideoId = state.video.id;
            loadLocalVideo(state, videoCfg);
          }

          if (!playerSubtitles) initPlayerSubtitles(state, videoCfg);

          renderClipSelect(state.video.id);

          if (state.receivedSubtitles) {
            receivedSound.currentTime = 0;
            receivedSound.play();

            if (currentViewId == "playerView") {
              submitButton.classList.remove("pulse-once"); // reset au cas oÃ¹
              void submitButton.offsetWidth; // force reflow
              submitButton.classList.add("pulse-once");
              submitButton.textContent = "ğŸ‘‹";
            }
          }

          // opti

          if (!isRemoteVisible) return;

          renderButton.disabled = state.timeline.length === 0;
          goToRender.disabled = !state.renderUrl;
          if (state.finishedRender) {
            goToRender.classList.remove("pulse-once"); // reset au cas oÃ¹
            void goToRender.offsetWidth; // force reflow
            goToRender.classList.add("pulse-once");
          }

          // Reset selectedClipToInsert si clip plus prÃ©sent
          if (selectedClipToInsert) {
            const saves = state.clipSaves?.[selectedClipToInsert.videoId] || [];
            const stillExists = saves.some(
              (s) => s.name === selectedClipToInsert.name
            );
            if (!stillExists) selectedClipToInsert = null;
          }
          timelineClips = state.timeline; // mise Ã  jour

          renderTimeline();
          renderSaves();

          let newEmoticons = {};
          Object.entries(state.emoticons).forEach(([name, text]) => {
            newEmoticons[name] = text;
            if (!currentEmoticons[name]) {
              const createEmoticon = () => {
                const emoticon = document.createElement("div");
                emoticon.className = "emoticon";
                const nameEl = document.createElement("div");
                nameEl.className = "emoticonName";
                nameEl.textContent = name;
                emoticon.appendChild(nameEl);
                const textEl = document.createElement("div");
                textEl.className = "emoticonText";
                textEl.textContent = text;
                emoticon.appendChild(textEl);

                // random position on videoContainer
                const videoRect = gameVideo.getBoundingClientRect();
                const x =
                  videoRect.width * 0.5 +
                  (Math.random() - 0.5) * 2 * videoRect.width * 0.3;
                const y =
                  -Math.random() * videoRect.height * 0.5 +
                  videoRect.bottom -
                  50;
                emoticon.style.left = `${x}px`;
                emoticon.style.top = `${y}px`;

                videoContainer.appendChild(emoticon);
                setTimeout(() => {
                  emoticon.remove();
                  currentEmoticons[name] = null;
                }, 3000);
              };
              createEmoticon();
            }
          });
          currentEmoticons = newEmoticons;

          saveButton.disabled =
            !state?.selectedPlayerId ||
            !state.players[state.selectedPlayerId]?.submitted;

          applyRemoteVideoState(state.video, videoCfg);
          renderPlayers(state);
        });

        const playerState = () => {
          if (!lastGameState) return null;

          const players = Object.values(lastGameState.players);
          for (let i = 0; i < players.length; i++) {
            if (players[i].name == playerName) return players[i];
          }

          return null;
        };

        clipSelect.onchange = () => {
          if (clipSelect.value)
            socket.emit("selectVideoById", clipSelect.value);
        };

        function renderPlayers(state) {
          playersList.innerHTML = Object.entries(state.players)
            .map(
              ([id, p]) =>
                `<div class="playerItem ${p.submitted ? "submitted" : ""} ${
                  state.selectedPlayerId === id ? "selected" : ""
                }" onclick="selectPlayer('${id}')"><span>ğŸ¤–</span><span>${
                  p.submitted ? "ğŸ“„" : "âŒ"
                }</span>
                                  </span><span>${
                                    !p.hasBeenSelected && p.submitted
                                      ? "ğŸ‘‹"
                                      : ""
                                  }</span><span style="margin-left: 8px">${
                  p.name
                }</span>

                                    </div>`
            )
            .join("");
        }

        window.selectPlayer = (id) => socket.emit("selectPlayer", id);

        function renderClipSelect(activeId) {
          clipSelect.innerHTML = "";

          Object.values(videosById)
            .sort((a, b) => a.id.toString().localeCompare(b.id.toString()))
            .forEach((v) => {
              const option = document.createElement("option");
              option.value = v.id;
              option.textContent = `${v.id} (${v.lang})`;

              if (v.id === activeId) {
                option.selected = true;
              }

              clipSelect.appendChild(option);
            });
        }

        function isTemplate(id) {
          return id.startsWith("template-");
        }

        function renderLibraryView() {
          const libraryVideos = Object.values(libraryVideosById);

          if (libraryVideos.length) {
            librarySelect.innerHTML = "";
            // Regrouper les vidÃ©os par langue
            const videosByLang = {};
            Object.values(libraryVideosById).forEach((v) => {
              if (!videosByLang[v.lang]) videosByLang[v.lang] = [];
              videosByLang[v.lang].push(v);
            });

            // CrÃ©er les optgroup
            Object.keys(videosByLang)
              .sort() // trier les langues par ordre alphabÃ©tique
              .forEach((lang) => {
                const optgroup = document.createElement("optgroup");
                optgroup.label = lang;

                // trier les vidÃ©os par id dans chaque langue
                videosByLang[lang]
                  .sort((a, b) =>
                    a.id.toString().localeCompare(b.id.toString())
                  )
                  .forEach((v) => {
                    const option = document.createElement("option");
                    option.value = v.id;
                    option.textContent = `${v.id}`;
                    optgroup.appendChild(option);
                  });

                librarySelect.appendChild(optgroup);
              });
          }

          libraryClipSelect.innerHTML = "";

          const clips = Object.values(videosById).filter(
            (v) => !isTemplate(v.id)
          );

          if (!clips.length) {
            const o = document.createElement("option");
            o.textContent = "Aucun clip crÃ©er";
            o.disabled = true;
            o.selected = true;
            libraryClipSelect.appendChild(o);
            return;
          }

          clips
            .sort((a, b) => a.id.toString().localeCompare(b.id.toString()))
            .forEach((v) => {
              const option = document.createElement("option");
              option.value = v.id;
              option.textContent = `${v.id} (${v.lang})`;
              libraryClipSelect.appendChild(option);
            });
        }

        renderLibraryView();

        deleteClipButton.onclick = () => {
          socket.emit("deleteClip", libraryClipSelect.value);
        };

        librarySelect.onchange = () => {
          libraryVideo.src = libraryVideosById[librarySelect.value].path;
          libraryVideoTrack.src = libraryVideosById[
            librarySelect.value
          ].srt.replace(/\.srt$/i, ".vtt");
        };

        /* ================= SAVE BUTTON ================= */
        let saveTriggered = false;

        const saveSubtitles = () => {
          if (saveTriggered) return; // empÃªche double clic
          saveTriggered = true;

          const name = saveNameInput.value.trim();
          if (!name || !lastGameState) {
            saveButton.textContent = "âŒ";
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾ğŸ“„â†’ğŸ“ğŸ“—";
              saveTriggered = false;
            }, 1000);
            return;
          }

          const { selectedPlayerId, players, video } = lastGameState;
          if (!selectedPlayerId || !players[selectedPlayerId]) {
            saveButton.textContent = "âŒ";
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾ğŸ“„â†’ğŸ“ğŸ“—";
              saveTriggered = false;
            }, 1000);
            return;
          }

          const subtitles = players[selectedPlayerId].subtitles;
          if (!subtitles || !subtitles.length) {
            saveButton.textContent = "âŒ";
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾ğŸ“„â†’ğŸ“ğŸ“—";
              saveTriggered = false;
            }, 1000);
            return;
          }

          // ğŸ”¹ Envoi via socket au lieu de localStorage
          socket.emit("saveRemoteSubtitles", {
            videoId: video.id,
            name,
            subtitles,
          });

          console.log(subtitles);

          // Feedback utilisateur
          saveButton.textContent = "âœ…";
          setTimeout(() => {
            saveButton.textContent = "ğŸ’¾ğŸ“„â†’ğŸ“ğŸ“—";
            saveTriggered = false;
          }, 1000);
        };

        // dÃ©clenchement unique pour click/touch
        saveButton.addEventListener("click", saveSubtitles);

        renderButton.addEventListener("click", () => {
          if (confirm("ğŸ“½ï¸ğŸ•” ?")) socket.emit("render");
        });
        goToRender.addEventListener("click", () => {
          window.location.href = "/render/final.mp4";
        });

        /* ================= LIBRARY VIEW ================= */

        const startInput = document.getElementById("startClipInput");
        const endInput = document.getElementById("endClipInput");
        const nameInput = document.getElementById("clipName");
        const createBtn = document.getElementById("createClip");

        const seekToInputValue = (input) => {
          if (!input.checkValidity()) return;

          const t = toSeconds(input.value);
          if (Number.isNaN(t)) return;

          libraryVideo.currentTime = t;
        };

        startInput.addEventListener("focus", () => {
          seekToInputValue(startInput);
        });

        startInput.addEventListener("input", () => {
          seekToInputValue(startInput);
        });

        endInput.addEventListener("focus", () => {
          seekToInputValue(endInput);
        });

        endInput.addEventListener("input", () => {
          seekToInputValue(endInput);
        });

        libraryVideo.addEventListener("timeupdate", () => {
          // VÃ©rifie que le champ est valide
          if (!endInput.checkValidity()) return;

          const endSec = toSeconds(endInput.value);
          if (!Number.isFinite(endSec)) return;

          // Si le temps courant dÃ©passe la fin, pause la vidÃ©o
          if (libraryVideo.currentTime >= endSec + 5 && !libraryVideo.paused) {
            libraryVideo.pause();
          }
        });

        createBtn.addEventListener("click", () => {
          // 1. Validation HTML native
          if (!startInput.checkValidity() || !endInput.checkValidity()) {
            // Force lâ€™affichage du message du navigateur
            startInput.reportValidity();
            endInput.reportValidity();
            return;
          }

          // 2. RÃ©cupÃ©ration des valeurs
          const start = startInput.value;
          const end = endInput.value;
          const name = nameInput.value.trim();

          if (!name) {
            alert("Nom du clip obligatoire");
            return;
          }

          const id = normalizeToId(name);

          if (videosById[id]) {
            alert("Un clip porte deja ce nom");
            return;
          }

          // 3. Conversion en secondes
          const startSec = toSeconds(start);
          const endSec = toSeconds(end);

          // 4. VÃ©rifications mÃ©tier
          if (endSec <= startSec) {
            alert("La fin doit Ãªtre aprÃ¨s le dÃ©but");
            return;
          }

          if (endSec - startSec < 5) {
            alert("La durÃ©e minimale est de 5 secondes");
            return;
          }

          if (endSec - startSec > 60 * 5) {
            alert("La durÃ©e maximale est de 5 minutes");
            return;
          }

          // 5. Utilisation finale
          createBtn.textContent = "âŒ›";

          createBtn.disabled = true;

          socket.emit("createClip", {
            libraryVideoId: librarySelect.value,
            lang: libraryVideosById[librarySelect.value].lang,
            clipId: id,
            start,
            end,
          });
        });

        /* ================= CLEAR BUTTON ================= */
        playerNameSpan.onclick = () => {
          if (!confirm("Changez de nom ?")) return;
          localStorage.setItem("playerName", "");
          window.location.reload();
        };

        /* ================= KEYBOARD ================= */
        window.addEventListener("keydown", (e) => {
          const tag = e.target.tagName;
          const isTyping =
            tag === "INPUT" || tag === "TEXTAREA" || e.target.isContentEditable;

          if (isTyping) return;

          if (e.key === "f" || e.key === "F") {
            if (!document.fullscreenElement) {
              videoContainer.requestFullscreen();
            } else {
              document.exitFullscreen();
            }
          }

          if (e.key === "Escape" && document.fullscreenElement) {
            document.exitFullscreen();
          }
        });

        /* ================= ACTION MENU ================= */
        document.querySelectorAll(".action-menu").forEach((menu) => {
          const toggle = menu.querySelector(".action-menu-toggle");
          const panel = menu.querySelector(".action-menu-panel");

          panel.querySelectorAll(".action-menu-item").forEach((btn) => {
            btn.addEventListener("click", () => {
              menu.classList.remove("open");

              const action = btn.dataset.action;

              switch (action) {
                case "emoticon":
                  socket.emit("emoticon", {
                    text: btn.textContent,
                    name: playerName,
                  });
                  break;
                case "playerView":
                case "remoteView":
                case "libraryView":
                  displayView(action);
                  break;
              }
            });
          });

          toggle.addEventListener("click", (e) => {
            e.stopPropagation();

            // fermer les autres menus
            document
              .querySelectorAll(".action-menu.open")
              .forEach((m) => m !== menu && m.classList.remove("open"));

            menu.classList.toggle("open");

            if (menu.classList.contains("open")) {
              const rectPannel = panel.getBoundingClientRect();
              const screenWidth = window.innerWidth;

              if (rectPannel.right > screenWidth) {
                panel.style.transform = `translateX(${
                  screenWidth - rectPannel.right
                }px)`;
              } else if (rectPannel.left < 0) {
                panel.style.transform = `translateX(${-rectPannel.left}px)`;
              }
            }
          });
        });

        // clic global â†’ fermer tous les menus
        document.addEventListener("click", () => {
          document
            .querySelectorAll(".action-menu.open")
            .forEach((m) => m.classList.remove("open"));
        });

        // pause button
        videoStateButton.onclick = () => {
          socket.emit("videoStateButtonClicked");
        };

        // init from cache
        const cachedViewId = localStorage.getItem("currentViewId");
        if (cachedViewId && cachedViewId !== "playerView") {
          displayView(cachedViewId);
        } else {
          requestAnimationFrame(() => updateHeight());
        }
      }

      function fmt(sec) {
        const d = new Date(0);
        d.setSeconds(sec);
        return d.toISOString().substr(11, 8);
      }
      function toSeconds(hhmmss) {
        const [h, m, s] = hhmmss.split(":").map(Number);
        return h * 3600 + m * 60 + s;
      }
      function normalizeToId(text) {
        return text
          .toString()
          .normalize("NFD") // sÃ©pare accents
          .replace(/[\u0300-\u036f]/g, "") // supprime accents
          .toLowerCase()
          .trim()
          .replace(/[^a-z0-9]+/g, "-") // caractÃ¨res non autorisÃ©s â†’ "-"
          .replace(/^-+|-+$/g, ""); // trim des "-"
      }

      window.addEventListener("DOMContentLoaded", main);
    </script>
  </body>
</html>
