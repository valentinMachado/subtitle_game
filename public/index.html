<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>client</title>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <!-- ================= VIDEO ================= -->
    <div id="videoContainer">
      <div id="viewInfo">âœ</div>
      <video id="gameVideo" controls playsinline></video>
      <video id="libraryVideo" controls style="display: none"></video>
      <div id="subtitleOverlayLocal" class="subtitleOverlay"></div>
      <div
        id="subtitleOverlayRemote"
        class="subtitleOverlay"
        style="display: none"
      ></div>
    </div>

    <!-- ================= PLAYER VIEW ================= -->
    <div id="playerView" class="viewContainer">
      <div id="subtitlesList"></div>
    </div>

    <!-- ================= REMOTE VIEW ================= -->
    <div
      id="remoteView"
      class="viewContainer"
      style="display: none; gap: 16px; max-width: 100vw"
    >
      <div style="display: flex; width: 100%; height: 100%">
        <!-- Colonne gauche -->
        <div style="flex: 1; display: flex; flex-direction: column; gap: 8px">
          <div id="playersList"></div>
        </div>

        <!-- Colonne droite -->
        <div
          style="
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 0;
          "
        >
          <div
            id="savesList"
            class="savesList"
            style="display: block; width: 100%; overflow-y: auto"
          ></div>
          <input
            id="saveNameInput"
            placeholder="Nom de la sauvegarde"
            value="sous-titres"
            style="display: none"
          />
          <button id="saveButton" disabled style="display: none">ğŸ’¾</button>
        </div>
      </div>
    </div>

    <!-- ================= LIBRARY VIEW ================= -->
    <div id="libraryView" class="viewContainer" style="display: none">
      <div class="libraryLayout">
        <select id="librarySelect"></select>

        <div class="libraryEditor">
          <label for="startClipInput">DÃ©but (hh:mm:ss)</label>
          <input
            id="startClipInput"
            type="text"
            required
            placeholder="00:00:00"
            pattern="^([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)$"
            title="Format attendu : hh:mm:ss"
          />

          <label for="endClipInput">Fin (hh:mm:ss)</label>
          <input
            id="endClipInput"
            type="text"
            required
            placeholder="00:00:00"
            pattern="^([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)$"
            title="Format attendu : hh:mm:ss"
          />

          <input
            id="clipName"
            required
            placeholder="Nom du clip"
            pattern=".*\S.*"
            title="Le nom du clip ne peut pas Ãªtre vide"
          />
          <button id="createClip">ğŸ’¾</button>
        </div>

        <select id="libraryClipSelect"></select>
        <button id="deleteClipButton">âŒ</button>
      </div>
    </div>

    <!-- ================= FOOTER ================= -->
    <div id="subtitleForm">
      <div class="row">
        <div id="viewActionMenu" class="action-menu">
          <button class="action-menu-toggle">ğŸ‘€</button>

          <div class="action-menu-panel">
            <button class="action-menu-item" data-action="libraryView">
              ğŸï¸
            </button>
            <button class="action-menu-item" data-action="remoteView">
              ğŸ¤
            </button>
            <button class="action-menu-item" data-action="playerView">
              âœ
            </button>
          </div>
        </div>

        <span id="playerName"></span>
        <button id="submitButton">ğŸ“„</button>
        <select id="clipSelect"></select>
        <button id="downloadButton" style="display: none" disabled>ğŸ’¾</button>

        <div id="emoticonActionMenu" class="action-menu" style="display: none">
          <button class="action-menu-toggle">ğŸ’¬</button>

          <div class="action-menu-panel">
            <button class="action-menu-item" data-action="emoticon">â›”</button>
            <button class="action-menu-item" data-action="emoticon">â“</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ™ƒ</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜…</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜‚</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ˜</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ‘</button>
            <button class="action-menu-item" data-action="emoticon">ğŸ™‚</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      async function main() {
        /* ================= DOM ================= */
        const viewInfo = document.getElementById("viewInfo");
        const gameVideo = document.getElementById("gameVideo");
        const libraryVideo = document.getElementById("libraryVideo");
        const subtitleOverlayLocal = document.getElementById(
          "subtitleOverlayLocal"
        );

        const videoContainer = document.getElementById("videoContainer");
        const subtitleOverlayRemote = document.getElementById(
          "subtitleOverlayRemote"
        );
        const subtitlesList = document.getElementById("subtitlesList");

        const subtitleForm = document.getElementById("subtitleForm");
        const submitButton = document.getElementById("submitButton");

        const saveButton = document.getElementById("saveButton");
        const saveNameInput = document.getElementById("saveNameInput");
        const downloadButton = document.getElementById("downloadButton");

        const emoticonActionMenu =
          document.getElementById("emoticonActionMenu");

        const playerNameSpan = document.getElementById("playerName");

        const playerView = document.getElementById("playerView");
        const remoteView = document.getElementById("remoteView");
        const libraryView = document.getElementById("libraryView");
        const librarySelect = document.getElementById("librarySelect");
        const libraryClipSelect = document.getElementById("libraryClipSelect");
        const deleteClipButton = document.getElementById("deleteClipButton");

        const clipSelect = document.getElementById("clipSelect");
        const playersList = document.getElementById("playersList");
        const savesList = document.getElementById("savesList");

        /* ================= STATE ================= */
        let videosById = {};
        let libraryVideosById = {};
        let currentViewId = "playerView";
        let playerSubtitles = [];
        let currentVideoId = null;
        let isEditingSubtitle = false;
        let isRemoteVisible = false;
        let applyingRemoteChange = false;
        let lastAppliedVideoState = { id: null, playing: null, time: null };
        let lastGameState = null;

        function savesKey(videoId) {
          return `savedSubs_${videoId}`;
        }

        function isMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        }

        /* ================= PLAYER NAME ================= */
        let playerName = localStorage.getItem("playerName");
        if (!playerName) {
          playerName = prompt(
            "Quel est ton pseudo ?",
            "Joueur " + Math.floor(Math.random() * 1000)
          );
          localStorage.setItem("playerName", playerName);
        }
        playerNameSpan.textContent = "ğŸ¤– " + playerName;

        /* ================= CONFIG ================= */
        const cfg = await fetch("/config.json").then((r) => r.json());
        videosById = Object.fromEntries(cfg.videos.map((v) => [v.id, v]));
        libraryVideosById = Object.fromEntries(
          cfg.library_videos.map((v) => [v.id, v])
        );

        /* ================= SOCKET ================= */
        const socket = io({ reconnection: true, timeout: 20000 });
        socket.on("connect", () =>
          socket.emit("register", { role: "player", playerName })
        );

        socket.on("reload", () => location.reload());

        /* ================= INIT DISPLAY ================= */
        gameVideo.style.display = "block";
        subtitleOverlayLocal.style.display = "block";
        subtitleOverlayRemote.style.display = "none";
        playerView.style.display = "block";
        remoteView.style.display = "none";

        const submitSubtitles = () => {
          if (
            playerSubtitles.length === 0 ||
            playerSubtitles.every((s) => !s.text || s.text === "")
          )
            return false;

          socket.emit(
            "submitSubtitles",
            playerSubtitles.map((s) => ({
              start: s.start,
              end: s.end,
              text: s.text || "",
              placeholder: s.placeholder,
            }))
          );

          return true;
        };

        const downloadButtonDisable = () => {
          return !playerSubtitles.every((s) => s.text && s.text !== "");
        };

        /* ================= LOCAL VIDEO ================= */
        function loadLocalVideo(state, videoCfg) {
          gameVideo.src = videoCfg.path;
          gameVideo.load();
          const cached = localStorage.getItem(`subs_${videoCfg.id}`);

          playerSubtitles = null;

          if (cached) {
            const subtitlesCached = JSON.parse(cached);
            playerSubtitles = videoCfg.subtitles.map((s, index) => {
              return {
                ...s,
                text: subtitlesCached[index] ? subtitlesCached[index].text : "",
              };
            });
          } else {
            for (let key in state.players) {
              if (playerName === state.players[key].name) {
                playerSubtitles = state.players[key].subtitles;
                break;
              }
            }

            if (!playerSubtitles) {
              playerSubtitles = videoCfg.subtitles.map((s) => ({
                ...s,
                text: "",
              }));
            }
          }

          localStorage.setItem(
            `subs_${currentVideoId}`,
            JSON.stringify(playerSubtitles)
          );
          cleanupOtherCaches(videoCfg.id);
          renderSubtitles();
          downloadButton.disabled = downloadButtonDisable();
        }

        function cleanupOtherCaches(id) {
          Object.keys(localStorage)
            .filter((k) => k.startsWith("subs_") && k !== `subs_${id}`)
            .forEach((k) => localStorage.removeItem(k));
        }

        function renderSubtitles() {
          subtitlesList.innerHTML = playerSubtitles
            .map(
              (s, i) => `
                                <div class="subtitleItem" id="sub-${i}">
                                    <button class="seekButton" onclick="seekTo(${
                                      s.start
                                    })">â–¶</button>
                                  <span class="subtitleTime">${fmt(
                                    s.start
                                  )} - ${fmt(s.end)}</span>
                                  <input class="subtitleInput"
                                    value="${s.text ? s.text : ""}"
                                    placeholder="${s.placeholder}"
                                    onfocus="focusSubtitle(${i})"
                                    onblur="stopEditing()"
                                    oninput="updateSubtitle(${i}, this.value)">
                                </div>`
            )
            .join("");
        }

        function renderSaves() {
          const state = lastGameState;
          if (!state?.video?.id) {
            savesList.innerHTML = "";
            return;
          }

          const key = savesKey(state.video.id);
          const cached = localStorage.getItem(key)
            ? localStorage.getItem(key)
            : null;

          const saves = cached ? JSON.parse(cached) : [];

          if (!saves.length) {
            savesList.innerHTML = "<em>Aucun sous-titre pour ce clip</em>";
            return;
          }

          savesList.innerHTML = saves
            .map(
              (s) => `
                          <div class="saveItem">
                            <span>${s.name}</span>
                            <div>
                              <button onclick="loadSave('${s.id}')">âœ</button>
                              <button onclick="deleteSave('${s.id}')">âŒ</button>
                            </div>
                          </div>
                        `
            )
            .join("");
        }

        const renderLocalOverlay = () => {
          const t = gameVideo.currentTime;
          const active = playerSubtitles.find(
            (s) => t >= s.start && t <= s.end
          );

          // Overlay local
          subtitlesList
            .querySelectorAll(".subtitleItem")
            .forEach((el, i) =>
              el.classList.toggle("active", playerSubtitles[i] === active)
            );

          if (active && !isRemoteVisible) {
            subtitleOverlayLocal.textContent =
              active.text || active.placeholder;
            subtitleOverlayLocal.style.display = "block";
            if (!isEditingSubtitle)
              scrollToSub(playerSubtitles.indexOf(active));
          } else subtitleOverlayLocal.style.display = "none";
        };

        const updateHeight = () => {
          const newHeight = window.innerHeight;

          const videoHeight = videoContainer.getBoundingClientRect().height;
          const subtitleFormHeight =
            subtitleForm.getBoundingClientRect().height;
          const viewHeight = newHeight - videoHeight - subtitleFormHeight;
          playerView.style.height = `${viewHeight}px`;
          remoteView.style.height = `${viewHeight}px`;
        };

        const displayView = (id) => {
          if (id === currentViewId) return;

          currentViewId = id;

          viewInfo.textContent =
            id === "playerView" ? "âœ" : id === "remoteView" ? "ğŸ¤" : "ğŸï¸";

          localStorage.setItem("currentViewId", currentViewId);
          playerView.style.display = id === "playerView" ? "block" : "none";
          remoteView.style.display = id === "remoteView" ? "block" : "none";
          libraryView.style.display = id === "libraryView" ? "block" : "none";

          gameVideo.style.display =
            id === "playerView" || id === "remoteView" ? "block" : "none";
          libraryVideo.style.display = id === "libraryView" ? "block" : "none";

          if (id === "playerView" || id === "remoteView") {
            socket.emit("needGameState");
          } else {
            libraryVideo.src = libraryVideosById[librarySelect.value].path;
          }

          clipSelect.style.display =
            id === "playerView" || id === "remoteView" ? "block" : "none";

          isRemoteVisible = id === "remoteView";

          subtitleOverlayLocal.style.display = isRemoteVisible
            ? "none"
            : "block";
          subtitleOverlayRemote.style.display = isRemoteVisible
            ? "block"
            : "none";

          downloadButton.style.display = isRemoteVisible ? "block" : "none";
          downloadButton.disabled = downloadButtonDisable();

          submitButton.style.display = isRemoteVisible ? "block" : "none";

          saveButton.style.display = !isRemoteVisible ? "none" : "block";
          saveNameInput.style.display = !isRemoteVisible ? "none" : "block";
          emoticonActionMenu.style.display = isRemoteVisible ? "block" : "none";
          gameVideo.controls = !isRemoteVisible;
          gameVideo.pause();

          requestAnimationFrame(() => updateHeight());
        };

        let resizeTimeout;
        let lastHeight = window.innerHeight;
        let currentSubtitleIndex = null;

        requestAnimationFrame(() => updateHeight());

        window.addEventListener("resize", () => {
          const newHeight = window.innerHeight;

          updateHeight();

          clearTimeout(resizeTimeout);

          // On attend que la hauteur se stabilise
          resizeTimeout = setTimeout(() => {
            if (newHeight === lastHeight) {
              // Ici tu peux scroll vers la subtitle active
              scrollToSub(currentSubtitleIndex, 400, false);
            } else if (newHeight > lastHeight) {
              showAllSubtitles();
            }
            lastHeight = newHeight;
          }, 50); // 50ms aprÃ¨s le dernier resize, la hauteur est stabilisÃ©e
        });

        window.loadSave = (saveId) => {
          if (!lastGameState?.video?.id) return;

          const key = savesKey(lastGameState.video.id);
          const cached = localStorage.getItem(key)
            ? localStorage.getItem(key)
            : null;

          const saves = cached ? JSON.parse(cached) : [];

          const save = saves.find((s) => s.id === saveId);
          if (!save) return;

          // âš ï¸ LOCAL UNIQUEMENT
          playerSubtitles = structuredClone(save.subtitles);

          // persistance locale
          localStorage.setItem(
            `subs_${lastGameState.video.id}`,
            JSON.stringify(playerSubtitles)
          );

          // ğŸ” rÃ©hydrater complÃ¨tement lâ€™UI
          renderSubtitles();

          // forcer recalcul overlay / active subtitle / scroll
          gameVideo.dispatchEvent(new Event("timeupdate"));
          if (isRemoteVisible) {
            displayView("playerView");
          }
        };

        window.deleteSave = (id) => {
          const { video, selectedPlayerId } = lastGameState;
          const key = savesKey(video.id);
          const saves = JSON.parse(localStorage.getItem(key) || "[]");

          localStorage.setItem(
            key,
            JSON.stringify(saves.filter((s) => s.id !== id))
          );

          renderSaves();
        };

        window.focusSubtitle = (i) => {
          isEditingSubtitle = true;
          gameVideo.pause();
          seekTo(playerSubtitles[i].start);

          if (!isMobile()) return;
          hideOtherSubtitles(i);
          currentSubtitleIndex = i;
        };
        window.stopEditing = () => {
          isEditingSubtitle = false;
          showAllSubtitles();
          downloadButton.disabled = downloadButtonDisable();
        };
        function hideOtherSubtitles(i) {
          document
            .querySelectorAll(".subtitleItem")
            .forEach((el, j) => (el.style.display = j >= i ? "flex" : "none"));
        }
        function showAllSubtitles() {
          document
            .querySelectorAll(".subtitleItem")
            .forEach((el) => (el.style.display = "flex"));
        }
        function scrollToSub(i, duration = 0, smooth = true) {
          const callback = () =>
            document.getElementById(`sub-${i}`)?.scrollIntoView({
              behavior: smooth ? "smooth" : "instant",
              block: "end",
            });
          if (duration === 0) callback();
          setTimeout(callback, duration);
        }
        window.updateSubtitle = (i, text) => {
          playerSubtitles[i].text = text;
          localStorage.setItem(
            `subs_${currentVideoId}`,
            JSON.stringify(playerSubtitles)
          );
          renderLocalOverlay();
        };
        window.seekTo = (t) => {
          gameVideo.currentTime = Math.min(gameVideo.duration, t + 0.01);
        };

        gameVideo.addEventListener("timeupdate", () => {
          // Overlay remote
          if (isRemoteVisible) renderRemoteSubtitles();
          else renderLocalOverlay();
        });

        submitButton.onclick = () => {
          const success = submitSubtitles();
          if (success && !isRemoteVisible) {
            displayView("remoteView");
          }

          submitButton.textContent = success ? "âœ…" : "âŒ";
          setTimeout(() => (submitButton.textContent = "ğŸ“„"), 1000);
        };

        /* ================= REMOTE VIDEO ================= */
        async function applyRemoteVideoState(videoState, videoCfg) {
          if (lastAppliedVideoState.id !== videoState.id) {
            applyingRemoteChange = true;
            gameVideo.src = videoCfg.path;
            applyingRemoteChange = false;
          }

          if (videoState.playing && gameVideo.paused) {
            applyingRemoteChange = true;
            gameVideo.play().catch(() => {});
            applyingRemoteChange = false;
          }
          if (!videoState.playing && !gameVideo.paused) {
            applyingRemoteChange = true;
            gameVideo.pause();
            applyingRemoteChange = false;
          }
          if (Math.abs(gameVideo.currentTime - videoState.time) > 1) {
            applyingRemoteChange = true;
            gameVideo.currentTime = videoState.time;
            applyingRemoteChange = false;
          }
          lastAppliedVideoState = { ...videoState };
        }

        function renderRemoteSubtitles() {
          if (!lastGameState) return;
          const t = gameVideo.currentTime;
          const {
            selectedPlayerId,
            players,
            video: videoState,
          } = lastGameState;
          const videoCfg = videosById[videoState.id];
          let activeSub = null;
          if (selectedPlayerId && players[selectedPlayerId])
            activeSub = players[selectedPlayerId].subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
          if (!activeSub && videoCfg?.subtitles) {
            const placeholder = videoCfg.subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
            if (placeholder) activeSub = { text: placeholder.placeholder };
          }
          if (activeSub) {
            subtitleOverlayRemote.textContent = activeSub.text
              ? activeSub.text
              : activeSub.placeholder;
            subtitleOverlayRemote.style.display = "block";
          } else subtitleOverlayRemote.style.display = "none";
        }

        /* ================= SOCKET GAMESTATE ================= */
        let currentEmoticons = {};
        socket.on("gameState", async (state) => {
          lastGameState = state;

          const videoCfg = videosById[state.video.id];

          if (currentVideoId !== state.video.id) {
            currentVideoId = state.video.id;
            loadLocalVideo(state, videoCfg);
          }

          renderClipSelect(state.video.id);

          if (!isRemoteVisible) return;

          renderSaves();

          let newEmoticons = {};
          Object.entries(state.emoticons).forEach(([name, text]) => {
            newEmoticons[name] = text;
            if (!currentEmoticons[name]) {
              const createEmoticon = () => {
                const emoticon = document.createElement("div");
                emoticon.className = "emoticon";
                const nameEl = document.createElement("div");
                nameEl.className = "emoticonName";
                nameEl.textContent = name;
                emoticon.appendChild(nameEl);
                const textEl = document.createElement("div");
                textEl.className = "emoticonText";
                textEl.textContent = text;
                emoticon.appendChild(textEl);

                // random position on videoContainer
                const videoRect = gameVideo.getBoundingClientRect();
                const x =
                  videoRect.width * 0.5 +
                  (Math.random() - 0.5) * 2 * videoRect.width * 0.3;
                const y =
                  -Math.random() * videoRect.height * 0.5 + videoRect.bottom;
                emoticon.style.left = `${x}px`;
                emoticon.style.top = `${y}px`;

                document.body.appendChild(emoticon);
                setTimeout(() => {
                  emoticon.remove();
                  currentEmoticons[name] = null;
                }, 3000);
              };
              createEmoticon();
            }
          });
          currentEmoticons = newEmoticons;

          saveButton.disabled =
            !state?.selectedPlayerId ||
            !state.players[state.selectedPlayerId]?.submitted;
          downloadButton.disabled = downloadButtonDisable();
          await applyRemoteVideoState(state.video, videoCfg);
          renderPlayers(state);
          const videoState = state.video;

          // Synchronisation vidÃ©o
          if (Math.abs(gameVideo.currentTime - videoState.time) > 1) {
            applyingRemoteChange = true;
            gameVideo.currentTime = videoState.time;
            applyingRemoteChange = false;
          }

          if (videoState.playing && gameVideo.paused) gameVideo.play();
          if (!videoState.playing && !gameVideo.paused) gameVideo.pause();
        });

        const playerState = () => {
          if (!lastGameState) return null;

          const players = Object.values(lastGameState.players);
          for (let i = 0; i < players.length; i++) {
            if (players[i].name == playerName) return players[i];
          }

          return null;
        };

        clipSelect.onchange = () => {
          if (clipSelect.value)
            socket.emit("selectVideoById", clipSelect.value);
        };

        function renderPlayers(state) {
          playersList.innerHTML = Object.entries(state.players)
            .map(
              ([id, p]) =>
                `<div class="playerItem ${p.submitted ? "submitted" : ""} ${
                  state.selectedPlayerId === id ? "selected" : ""
                }" onclick="selectPlayer('${id}')"><span>ğŸ¤–</span><span>${
                  p.submitted ? "ğŸ“„" : "âŒ"
                }</span>
                                  </span><span>${
                                    p.submitHasBeenPlayed ? "" : "ğŸ‘‹"
                                  }</span><span>${p.name}</span>

                                    </div>`
            )
            .join("");
        }
        window.selectPlayer = (id) => socket.emit("selectPlayer", id);
        function renderClipSelect(activeId) {
          clipSelect.innerHTML = "";

          Object.values(videosById)
            .sort((a, b) => a.id.toString().localeCompare(b.id.toString()))
            .forEach((v) => {
              const option = document.createElement("option");
              option.value = v.id;
              option.textContent = `${v.id} (${v.lang})`;

              if (v.id === activeId) {
                option.selected = true;
              }

              clipSelect.appendChild(option);
            });
        }

        function renderLibraryView() {
          librarySelect.innerHTML = "";

          Object.values(libraryVideosById)
            .sort((a, b) => a.id.toString().localeCompare(b.id.toString()))
            .forEach((v) => {
              const option = document.createElement("option");
              option.value = v.id;
              option.textContent = `${v.id} (${v.lang})`;
              librarySelect.appendChild(option);
            });

          libraryClipSelect.innerHTML = "";

          Object.values(videosById)
            .sort((a, b) => a.id.toString().localeCompare(b.id.toString()))
            .forEach((v) => {
              if (v.id === "tutoriel") return;
              const option = document.createElement("option");
              option.value = v.id;
              option.textContent = `${v.id} (${v.lang})`;
              libraryClipSelect.appendChild(option);
            });
        }
        renderLibraryView();

        deleteClipButton.onclick = () => {
          socket.emit("deleteClip", libraryClipSelect.value);
        };

        librarySelect.onchange = () => {
          libraryVideo.src = libraryVideosById[librarySelect.value].path;
        };

        /* ================= SAVE BUTTON ================= */
        let saveTriggered = false;

        const saveSubtitles = () => {
          if (saveTriggered) return; // empÃªche double trigger
          saveTriggered = true;

          try {
            const name = saveNameInput.value.trim();
            if (!name || !lastGameState) {
              saveButton.textContent = "âŒ Nom invalide";
              setTimeout(() => {
                saveButton.textContent = "ğŸ’¾";
                saveTriggered = false;
              }, 1000);
              return;
            }

            const { selectedPlayerId, players, video } = lastGameState;
            if (!selectedPlayerId || !players[selectedPlayerId]) {
              saveButton.textContent = "âŒ";
              setTimeout(() => {
                saveButton.textContent = "ğŸ’¾";
                saveTriggered = false;
              }, 1000);
              return;
            }

            const subtitles = players[selectedPlayerId].subtitles;
            if (!subtitles || !subtitles.length) {
              saveButton.textContent = "âŒ";
              setTimeout(() => {
                saveButton.textContent = "ğŸ’¾";
                saveTriggered = false;
              }, 1000);
              return;
            }

            const key = savesKey(video.id);

            const cached = localStorage.getItem(key)
              ? localStorage.getItem(key)
              : null;

            const saves = cached ? JSON.parse(cached) : [];

            saves.push({
              id: Date.now().toString(),
              name,
              date: Date.now(),
              subtitles,
            });

            try {
              localStorage.setItem(key, JSON.stringify(saves));
            } catch (e) {
              saveButton.textContent = "âŒ";
              setTimeout(() => {
                saveButton.textContent = "ğŸ’¾";
                saveTriggered = false;
              }, 1000);
              return;
            }

            renderSaves();

            saveButton.textContent = "âœ…";
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾";
              saveTriggered = false;
            }, 1000);
          } catch (e) {
            console.error(e);
            saveButton.textContent = "âŒ " + e.message;
          } finally {
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾";
              saveTriggered = false;
            }, 1000);
          }
        };

        // dÃ©clenchement unique pour click/touch
        saveButton.addEventListener("click", saveSubtitles);

        let flagDownload = false;
        socket.on("render_done", ({ url }) => {
          // CrÃ©er un lien temporaire pour dÃ©clencher le tÃ©lÃ©chargement
          const a = document.createElement("a");
          a.href = url;
          a.setAttribute("target", "_blank");
          a.click();
          downloadButton.textContent = "ğŸ’¾";
          flagDownload = false;
        });
        downloadButton.onclick = () => {
          if (flagDownload) return;
          flagDownload = true;
          downloadButton.textContent = "âŒ›";
          socket.emit("render", {
            isRemoteVisible,
            playerSubtitles,
          });
        };

        /* ================= LIBRARY VIEW ================= */

        const startInput = document.getElementById("startClipInput");
        const endInput = document.getElementById("endClipInput");
        const nameInput = document.getElementById("clipName");
        const createBtn = document.getElementById("createClip");

        const seekToInputValue = (input) => {
          if (!input.checkValidity()) return;

          const t = toSeconds(input.value);
          if (Number.isNaN(t)) return;

          libraryVideo.currentTime = t;
        };

        startInput.addEventListener("focus", () => {
          seekToInputValue(startInput);
        });

        startInput.addEventListener("input", () => {
          seekToInputValue(startInput);
        });

        endInput.addEventListener("focus", () => {
          seekToInputValue(endInput);
        });

        endInput.addEventListener("input", () => {
          seekToInputValue(endInput);
        });

        libraryVideo.addEventListener("timeupdate", () => {
          // VÃ©rifie que le champ est valide
          if (!endInput.checkValidity()) return;

          const endSec = toSeconds(endInput.value);
          if (!Number.isFinite(endSec)) return;

          // Si le temps courant dÃ©passe la fin, pause la vidÃ©o
          if (libraryVideo.currentTime >= endSec) {
            libraryVideo.pause();
            libraryVideo.currentTime = endSec; // optionnel : ajuste exactement Ã  la fin
          }
        });

        let isCreatingClip = false;
        createBtn.addEventListener("click", () => {
          if (isCreatingClip) return;

          // 1. Validation HTML native
          if (!startInput.checkValidity() || !endInput.checkValidity()) {
            // Force lâ€™affichage du message du navigateur
            startInput.reportValidity();
            endInput.reportValidity();
            return;
          }

          // 2. RÃ©cupÃ©ration des valeurs
          const start = startInput.value;
          const end = endInput.value;
          const name = nameInput.value.trim();

          if (!name) {
            alert("Nom du clip obligatoire");
            return;
          }

          const id = normalizeToId(name);

          if (videosById[id]) {
            alert("Un clip porte deja ce nom");
            return;
          }

          // 3. Conversion en secondes
          const startSec = toSeconds(start);
          const endSec = toSeconds(end);

          // 4. VÃ©rifications mÃ©tier
          if (endSec <= startSec) {
            alert("La fin doit Ãªtre aprÃ¨s le dÃ©but");
            return;
          }

          if (endSec - startSec < 5) {
            alert("La durÃ©e minimale est de 5 secondes");
            return;
          }

          if (endSec - startSec > 120) {
            alert("La durÃ©e maximale est de 2 minutes");
            return;
          }

          // 5. Utilisation finale
          createBtn.textContent = "âŒ›";

          isCreatingClip = true;

          socket.emit("createClip", {
            libraryVideoId: librarySelect.value,
            lang: libraryVideosById[librarySelect.value].lang,
            id,
            start,
            end,
          });
        });

        /* ================= CLEAR BUTTON ================= */
        playerNameSpan.onclick = () => {
          if (!confirm("Changez de nom ?")) return;
          localStorage.setItem("playerName", "");
          window.location.reload();
        };

        /* ================= ACTION MENU ================= */
        document.querySelectorAll(".action-menu").forEach((menu) => {
          const toggle = menu.querySelector(".action-menu-toggle");
          const items = menu.querySelectorAll(".action-menu-item");

          toggle.addEventListener("click", (e) => {
            e.stopPropagation();

            // fermer les autres menus
            document
              .querySelectorAll(".action-menu.open")
              .forEach((m) => m !== menu && m.classList.remove("open"));

            menu.classList.toggle("open");
          });

          items.forEach((btn) => {
            btn.addEventListener("click", () => {
              menu.classList.remove("open");

              const action = btn.dataset.action;

              switch (action) {
                case "emoticon":
                  socket.emit("emoticon", {
                    text: btn.textContent,
                    name: playerName,
                  });
                  break;
                case "playerView":
                case "remoteView":
                case "libraryView":
                  displayView(action);
                  break;
              }
            });
          });
        });

        // clic global â†’ fermeture
        document.addEventListener("click", () => {
          document
            .querySelectorAll(".action-menu.open")
            .forEach((m) => m.classList.remove("open"));
        });

        // init from cache
        const cachedViewId = localStorage.getItem("currentViewId");
        if (cachedViewId) displayView(cachedViewId);
      }

      function fmt(sec) {
        const d = new Date(0);
        d.setSeconds(sec);
        return d.toISOString().substr(11, 8);
      }
      function toSeconds(hhmmss) {
        const [h, m, s] = hhmmss.split(":").map(Number);
        return h * 3600 + m * 60 + s;
      }
      function normalizeToId(text) {
        return text
          .toString()
          .normalize("NFD") // sÃ©pare accents
          .replace(/[\u0300-\u036f]/g, "") // supprime accents
          .toLowerCase()
          .trim()
          .replace(/[^a-z0-9]+/g, "-") // caractÃ¨res non autorisÃ©s â†’ "-"
          .replace(/^-+|-+$/g, ""); // trim des "-"
      }

      main();
    </script>
  </body>
</html>
