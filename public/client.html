<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Client ‚Äì Sous-titres / T√©l√©commande</title>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <!-- ================= VIDEO ================= -->
    <div id="videoContainer">
      <video id="video" controls playsinline></video>
      <div id="subtitleOverlayLocal" class="subtitleOverlay"></div>
      <div
        id="subtitleOverlayRemote"
        class="subtitleOverlay"
        style="display: none"
      ></div>
    </div>

    <!-- ================= PLAYER VIEW ================= -->
    <div id="playerView">
      <div id="subtitlesList"></div>
    </div>

    <!-- ================= REMOTE VIEW ================= -->
    <div id="remoteView" style="display: none">
      <button id="playButton">‚ñ∂</button>
      <button id="pauseButton">||</button>
      <input type="range" id="seekBar" min="0" max="100" value="0" />
      <select id="videoSelect" style="width: 100%; margin: 8px 0"></select>
      <div id="playersList"></div>
      <div id="savesList" class="savesList"></div>
    </div>

    <!-- ================= FOOTER ================= -->
    <div id="subtitleForm">
      <div class="row">
        <button id="submitButton" disabled>‚ùå</button>
        <button id="toggleView" class="secondary">Salon</button>
        <input id="saveNameInput" placeholder="Nom de la sauvegarde" />
        <button id="saveButton" class="secondary" disabled>Savegarder</button>
        <span id="playerName"></span>
      </div>
    </div>

    <script>
      async function main() {
        /* ================= DOM ================= */
        const video = document.getElementById("video");
        const subtitleOverlayLocal = document.getElementById(
          "subtitleOverlayLocal"
        );
        const subtitleOverlayRemote = document.getElementById(
          "subtitleOverlayRemote"
        );
        const subtitlesList = document.getElementById("subtitlesList");

        const submitButton = document.getElementById("submitButton");
        const toggleViewBtn = document.getElementById("toggleView");
        const saveButton = document.getElementById("saveButton");
        const playerNameSpan = document.getElementById("playerName");

        const playerView = document.getElementById("playerView");
        const remoteView = document.getElementById("remoteView");

        const playButton = document.getElementById("playButton");
        const pauseButton = document.getElementById("pauseButton");
        const seekBar = document.getElementById("seekBar");
        const videoSelect = document.getElementById("videoSelect");
        const playersList = document.getElementById("playersList");
        const savesList = document.getElementById("savesList");

        /* ================= STATE ================= */
        let videosById = {};
        let playerSubtitles = [];
        let currentVideoId = null;
        let isEditingSubtitle = false;
        let isRemoteVisible = false;
        let applyingRemoteChange = false;
        let lastAppliedVideoState = { id: null, playing: null, time: null };
        let lastGameState = null;

        function savesKey(videoId) {
          return `savedSubs_${videoId}`;
        }

        function isMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        }

        /* ================= PLAYER NAME ================= */
        let playerName = localStorage.getItem("playerName");
        if (!playerName) {
          playerName =
            prompt(
              "Quel est ton pseudo ?",
              "Joueur " + Math.floor(Math.random() * 1000)
            ) || "Joueur";
          localStorage.setItem("playerName", playerName);
        }
        playerNameSpan.textContent = playerName;

        /* ================= CONFIG ================= */
        const cfg = await fetch("/config.json").then((r) => r.json());
        videosById = Object.fromEntries(cfg.videos.map((v) => [v.id, v]));

        /* ================= SOCKET ================= */
        const socket = io({ reconnection: true, timeout: 20000 });
        socket.on("connect", () =>
          socket.emit("register", { role: "player", playerName })
        );

        /* ================= INIT DISPLAY ================= */
        video.style.display = "block";
        subtitleOverlayLocal.style.display = "block";
        subtitleOverlayRemote.style.display = "none";
        playerView.style.display = "block";
        remoteView.style.display = "none";

        /* ================= LOCAL VIDEO ================= */
        function loadLocalVideo(videoCfg) {
          video.src = videoCfg.path;
          video.load();
          const cached = localStorage.getItem(`subs_${videoCfg.id}`);
          playerSubtitles = cached
            ? JSON.parse(cached)
            : videoCfg.subtitles.map((s) => ({ ...s, text: "" }));
          cleanupOtherCaches(videoCfg.id);
          renderSubtitles();
          submitButton.disabled = !playerSubtitles.every((s) => s.text.trim());
        }

        function cleanupOtherCaches(id) {
          Object.keys(localStorage)
            .filter((k) => k.startsWith("subs_") && k !== `subs_${id}`)
            .forEach((k) => localStorage.removeItem(k));
        }

        function renderSubtitles() {
          subtitlesList.innerHTML = playerSubtitles
            .map(
              (s, i) => `
            <div class="subtitleItem" id="sub-${i}">
                <button class="seekButton" onclick="seekTo(${
                  s.start
                })">‚ñ∂</button>
              <span class="subtitleTime">${fmt(s.start)} - ${fmt(s.end)}</span>
              <input class="subtitleInput"
                value="${s.text}"
                placeholder="${s.placeholder}"
                onfocus="focusSubtitle(${i})"
                onblur="stopEditing()"
                oninput="updateSubtitle(${i}, this.value)">
            </div>`
            )
            .join("");
        }

        function renderSaves() {
          const state = lastGameState;
          if (!state?.video?.id) {
            savesList.innerHTML = "";
            return;
          }

          const key = savesKey(state.video.id);
          const saves = JSON.parse(localStorage.getItem(key) || "[]");

          if (!saves.length) {
            savesList.innerHTML = "<em>Aucune sauvegarde pour cette vid√©o</em>";
            return;
          }

          savesList.innerHTML = saves
            .map(
              (s) => `
      <div class="saveItem">
        <span>${s.name}</span>
        <div>
          <button onclick="loadSave('${s.id}')">‚Üª</button>
          <button onclick="deleteSave('${s.id}')">üóë</button>
        </div>
      </div>
    `
            )
            .join("");
        }

        let resizeTimeout;
        let lastHeight = window.innerHeight;
        let currentSubtitleIndex = null;

        window.addEventListener("resize", () => {
          const newHeight = window.innerHeight;

          clearTimeout(resizeTimeout);

          // On attend que la hauteur se stabilise
          resizeTimeout = setTimeout(() => {
            if (newHeight === lastHeight) {
              // Ici tu peux scroll vers la subtitle active
              scrollToSub(currentSubtitleIndex, 400, false);
            } else if (newHeight > lastHeight) {
              showAllSubtitles();
            }
            lastHeight = newHeight;
          }, 50); // 50ms apr√®s le dernier resize, la hauteur est stabilis√©e
        });

        window.loadSave = (saveId) => {
          if (!lastGameState?.video?.id) return;

          const key = savesKey(lastGameState.video.id);
          const saves = JSON.parse(localStorage.getItem(key) || "[]");

          const save = saves.find((s) => s.id === saveId);
          if (!save) return;

          // ‚ö†Ô∏è LOCAL UNIQUEMENT
          playerSubtitles = structuredClone(save.subtitles);

          // persistance locale
          localStorage.setItem(
            `subs_${lastGameState.video.id}`,
            JSON.stringify(playerSubtitles)
          );

          // üîÅ r√©hydrater compl√®tement l‚ÄôUI
          renderSubtitles();

          submitButton.disabled = !playerSubtitles.every(
            (s) => s.text && s.text.trim()
          );

          // forcer recalcul overlay / active subtitle / scroll
          video.dispatchEvent(new Event("timeupdate"));
        };

        window.deleteSave = (id) => {
          const { video, selectedPlayerId } = lastGameState;
          const key = savesKey(video.id);
          const saves = JSON.parse(localStorage.getItem(key) || "[]");

          localStorage.setItem(
            key,
            JSON.stringify(saves.filter((s) => s.id !== id))
          );

          renderSaves();
        };

        window.focusSubtitle = (i) => {
          isEditingSubtitle = true;
          video.pause();
          seekTo(playerSubtitles[i].start);

          if (!isMobile()) return;
          hideOtherSubtitles(i);
          currentSubtitleIndex = i;
        };
        window.stopEditing = () => {
          isEditingSubtitle = false;
          showAllSubtitles();
        };
        function hideOtherSubtitles(i) {
          document
            .querySelectorAll(".subtitleItem")
            .forEach((el, j) => (el.style.display = j === i ? "flex" : "none"));
        }
        function showAllSubtitles() {
          document
            .querySelectorAll(".subtitleItem")
            .forEach((el) => (el.style.display = "flex"));
        }
        function scrollToSub(i, duration = 0, smooth = true) {
          const callback = () =>
            document.getElementById(`sub-${i}`)?.scrollIntoView({
              behavior: smooth ? "smooth" : "instant",
              block: "end",
            });
          if (duration === 0) callback();
          setTimeout(callback, duration);
        }
        window.updateSubtitle = (i, text) => {
          playerSubtitles[i].text = text;
          localStorage.setItem(
            `subs_${currentVideoId}`,
            JSON.stringify(playerSubtitles)
          );
          submitButton.disabled = !playerSubtitles.every((s) => s.text.trim());
        };
        window.seekTo = (t) => {
          video.currentTime = Math.min(video.duration, t + 0.1);
        };

        video.addEventListener("timeupdate", () => {
          const t = video.currentTime;
          const active = playerSubtitles.find(
            (s) => t >= s.start && t <= s.end
          );

          // Overlay local
          subtitlesList
            .querySelectorAll(".subtitleItem")
            .forEach((el, i) =>
              el.classList.toggle("active", playerSubtitles[i] === active)
            );

          if (active && !isRemoteVisible) {
            subtitleOverlayLocal.textContent =
              active.text || active.placeholder;
            subtitleOverlayLocal.style.display = "block";
            if (!isEditingSubtitle)
              scrollToSub(playerSubtitles.indexOf(active));
          } else subtitleOverlayLocal.style.display = "none";

          // Overlay remote
          if (isRemoteVisible) renderRemoteSubtitles();
        });

        submitButton.onclick = () => {
          if (!playerSubtitles.every((s) => s.text.trim())) return;
          socket.emit("submitSubtitles", playerSubtitles);
          submitButton.textContent = "‚Üª";
        };

        /* ================= REMOTE VIDEO ================= */
        function applyRemoteVideoState(videoState, videoCfg) {
          if (lastAppliedVideoState.id !== videoState.id) {
            applyingRemoteChange = true;
            video.src = videoCfg.path;
            video.load();
            applyingRemoteChange = false;
          }
          if (
            videoState.duration > 0 &&
            videoState.time >= videoState.duration
          ) {
            applyingRemoteChange = true;
            video.pause();
            video.currentTime = videoState.duration;
            applyingRemoteChange = false;
            return;
          }

          if (videoState.playing && video.paused) {
            applyingRemoteChange = true;
            video.play().catch(() => {});
            applyingRemoteChange = false;
          }
          if (!videoState.playing && !video.paused) {
            applyingRemoteChange = true;
            video.pause();
            applyingRemoteChange = false;
          }
          if (Math.abs(video.currentTime - videoState.time) > 1) {
            applyingRemoteChange = true;
            video.currentTime = videoState.time;
            applyingRemoteChange = false;
          }
          lastAppliedVideoState = { ...videoState };
        }

        function renderRemoteSubtitles() {
          if (!lastGameState) return;
          const t = video.currentTime;
          const {
            selectedPlayerId,
            players,
            video: videoState,
          } = lastGameState;
          const videoCfg = videosById[videoState.id];
          let activeSub = null;
          if (selectedPlayerId && players[selectedPlayerId])
            activeSub = players[selectedPlayerId].subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
          if (!activeSub && videoCfg?.subtitles) {
            const placeholder = videoCfg.subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
            if (placeholder) activeSub = { text: placeholder.placeholder };
          }
          if (activeSub) {
            subtitleOverlayRemote.textContent = activeSub.text;
            subtitleOverlayRemote.style.display = "block";
          } else subtitleOverlayRemote.style.display = "none";
        }

        /* ================= SOCKET GAMESTATE ================= */

        socket.on("gameState", (state) => {
          saveButton.disabled = !state?.selectedPlayerId;

          const videoCfg = videosById[state.video.id];
          if (!videoCfg) return;

          const remoteDuration = state.video.duration;
          lastGameState = state;

          if (currentVideoId !== state.video.id) {
            currentVideoId = state.video.id;
            loadLocalVideo(videoCfg);
            renderSaves();
          }

          // appliquer la remote video seulement si on est en remote view
          if (isRemoteVisible) {
            applyRemoteVideoState(state.video, videoCfg);
            // update seekBar toujours selon gameState
            seekBar.value =
              remoteDuration > 0
                ? (state.video.time / remoteDuration) * 100
                : 0;
          }

          seekBar.value =
            remoteDuration > 0 ? (state.video.time / remoteDuration) * 100 : 0;
          renderPlayers(state);
          renderVideoSelect(state.video.id);
        });

        socket.on("gameState", (state) => {
          if (!isRemoteVisible) return;
          const videoState = state.video;

          if (videoState.duration > 0) {
            seekBar.value = (videoState.time / videoState.duration) * 100;
          }

          // Synchronisation vid√©o
          if (Math.abs(video.currentTime - videoState.time) > 1) {
            applyingRemoteChange = true;
            video.currentTime = videoState.time;
            applyingRemoteChange = false;
          }

          if (videoState.playing && video.paused) video.play();
          if (!videoState.playing && !video.paused) video.pause();
        });

        /* ================= REMOTE CONTROLS ================= */
        playButton.onclick = () => socket.emit("remotePlay");
        pauseButton.onclick = () => socket.emit("remotePause");

        let isSeeking = false;

        seekBar.oninput = () => {
          if (lastGameState?.video.duration > 0) {
            isSeeking = true;
            socket.emit(
              "remoteSeek",
              (seekBar.value / 100) * lastGameState?.video.duration
            );
          }
        };

        seekBar.onchange = () => {
          // une fois que le slider est l√¢ch√©
          isSeeking = false;
        };

        videoSelect.onchange = () => {
          if (videoSelect.value)
            socket.emit("selectVideoById", videoSelect.value);
        };

        function renderPlayers(state) {
          playersList.innerHTML = Object.entries(state.players)
            .map(
              ([id, p]) =>
                `<div class="playerItem ${p.submitted ? "submitted" : ""} ${
                  state.selectedPlayerId === id ? "selected" : ""
                }" onclick="selectPlayer('${id}')"><span>${
                  p.name
                }</span><span>${p.submitted ? "‚úÖ" : "‚ùå"}</span></div>`
            )
            .join("");
        }
        window.selectPlayer = (id) => socket.emit("selectPlayer", id);
        function renderVideoSelect(activeId) {
          videoSelect.innerHTML =
            `<option value="">S√©lectionner une vid√©o</option>` +
            Object.values(videosById)
              .map(
                (v) =>
                  `<option value="${v.id}" ${
                    v.id === activeId ? "selected" : ""
                  }>${v.title || v.id}</option>`
              )
              .join("");
        }

        /* ================= TOGGLE VIEW ================= */
        toggleViewBtn.onclick = () => {
          isRemoteVisible = !isRemoteVisible;
          subtitleOverlayLocal.style.display = isRemoteVisible
            ? "none"
            : "block";
          subtitleOverlayRemote.style.display = isRemoteVisible
            ? "block"
            : "none";
          playerView.style.display = isRemoteVisible ? "none" : "block";
          remoteView.style.display = isRemoteVisible ? "block" : "none";
          toggleViewBtn.textContent = isRemoteVisible ? "Editeur" : "Salon";

          video.controls = !isRemoteVisible;
          video.pause();
        };
        /* ================= SAVE BUTTON ================= */
        let saveTriggered = false;

        const saveSubtitles = () => {
          if (saveTriggered) return; // emp√™che double trigger
          saveTriggered = true;

          const name = saveNameInput.value.trim();
          if (!name || !lastGameState) {
            saveTriggered = false;
            return;
          }

          const { selectedPlayerId, players, video } = lastGameState;
          if (!selectedPlayerId || !players[selectedPlayerId]) {
            saveTriggered = false;
            return;
          }

          const subtitles = players[selectedPlayerId].subtitles;
          if (!subtitles || !subtitles.length) {
            saveTriggered = false;
            return;
          }

          const key = savesKey(video.id);
          const saves = JSON.parse(localStorage.getItem(key) || "[]");

          saves.push({
            id: crypto.randomUUID(),
            name,
            date: Date.now(),
            subtitles,
          });

          localStorage.setItem(key, JSON.stringify(saves));
          renderSaves();

          saveButton.textContent = "‚úÖ Saved";
          setTimeout(() => {
            saveButton.textContent = "Save";
            saveTriggered = false;
          }, 1000);
        };

        // d√©clenchement unique pour click/touch
        saveButton.addEventListener("click", saveSubtitles);
      }

      function fmt(sec) {
        const d = new Date(0);
        d.setSeconds(sec);
        return d.toISOString().substr(11, 8);
      }
      main();
    </script>
  </body>
</html>
