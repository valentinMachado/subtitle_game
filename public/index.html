<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Client â€“ Sous-titres / TÃ©lÃ©commande</title>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <!-- ================= VIDEO ================= -->
    <div id="videoContainer">
      <video id="video" controls playsinline></video>
      <div id="subtitleOverlayLocal" class="subtitleOverlay"></div>
      <div
        id="subtitleOverlayRemote"
        class="subtitleOverlay"
        style="display: none"
      ></div>
    </div>

    <!-- ================= PLAYER VIEW ================= -->
    <div id="playerView">
      <div id="subtitlesList"></div>
    </div>

    <!-- ================= REMOTE VIEW ================= -->
    <div id="remoteView" style="display: none">
      <select id="videoSelect" style="width: 100%; margin: 8px 0"></select>
      <div id="playersList"></div>
      <div id="savesList" class="savesList"></div>
    </div>

    <!-- ================= FOOTER ================= -->
    <div id="subtitleForm">
      <div class="row">
        <button id="submitButton">ğŸ“¬</button>
        <button id="toggleView">ğŸ‘‹</button>
        <input
          id="saveNameInput"
          placeholder="Nom de la sauvegarde"
          value="Sauvegarde"
        />
        <button id="saveButton" disabled>ğŸ’¾</button>
        <button id="downloadButton" disabled>â¬‡ï¸</button>
        <span id="playerName"></span>
        <button id="clearButton">ğŸ”„</button>
      </div>
    </div>

    <script>
      async function main() {
        /* ================= DOM ================= */
        const video = document.getElementById("video");
        const subtitleOverlayLocal = document.getElementById(
          "subtitleOverlayLocal"
        );

        const videoContainer = document.getElementById("videoContainer");
        const subtitleOverlayRemote = document.getElementById(
          "subtitleOverlayRemote"
        );
        const subtitlesList = document.getElementById("subtitlesList");

        const subtitleForm = document.getElementById("subtitleForm");
        const submitButton = document.getElementById("submitButton");
        const toggleViewBtn = document.getElementById("toggleView");
        const saveButton = document.getElementById("saveButton");
        const downloadButton = document.getElementById("downloadButton");
        const clearButton = document.getElementById("clearButton");

        const playerNameSpan = document.getElementById("playerName");

        const playerView = document.getElementById("playerView");
        const remoteView = document.getElementById("remoteView");

        const videoSelect = document.getElementById("videoSelect");
        const playersList = document.getElementById("playersList");
        const savesList = document.getElementById("savesList");

        /* ================= STATE ================= */
        let videosById = {};
        let playerSubtitles = [];
        let currentVideoId = null;
        let isEditingSubtitle = false;
        let isRemoteVisible = false;
        let applyingRemoteChange = false;
        let lastAppliedVideoState = { id: null, playing: null, time: null };
        let lastGameState = null;

        function savesKey(videoId) {
          return `savedSubs_${videoId}`;
        }

        function isMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        }

        /* ================= PLAYER NAME ================= */
        let playerName = localStorage.getItem("playerName");
        if (!playerName) {
          playerName =
            prompt(
              "Quel est ton pseudo ?",
              "Joueur " + Math.floor(Math.random() * 1000)
            ) || "Joueur";
          localStorage.setItem("playerName", playerName);
        }
        playerNameSpan.textContent = playerName;

        /* ================= CONFIG ================= */
        const cfg = await fetch("/config.json").then((r) => r.json());
        videosById = Object.fromEntries(cfg.videos.map((v) => [v.id, v]));

        /* ================= SOCKET ================= */
        const socket = io({ reconnection: true, timeout: 20000 });
        socket.on("connect", () =>
          socket.emit("register", { role: "player", playerName })
        );

        socket.on("reload", () => location.reload());

        /* ================= INIT DISPLAY ================= */
        video.style.display = "block";
        subtitleOverlayLocal.style.display = "block";
        subtitleOverlayRemote.style.display = "none";
        playerView.style.display = "block";
        remoteView.style.display = "none";

        const submitSubtitles = () => {
          socket.emit(
            "submitSubtitles",
            playerSubtitles.map((s) => ({
              start: s.start,
              end: s.end,
              text: s.text || "",
              placeholder: s.placeholder,
            }))
          );
        };

        /* ================= LOCAL VIDEO ================= */
        function loadLocalVideo(videoCfg) {
          video.src = videoCfg.path;
          video.load();
          const cached = localStorage.getItem(`subs_${videoCfg.id}`);
          playerSubtitles = cached
            ? JSON.parse(cached)
            : videoCfg.subtitles.map((s) => ({ ...s, text: "" }));
          cleanupOtherCaches(videoCfg.id);
          renderSubtitles();
          submitSubtitles();
        }

        function cleanupOtherCaches(id) {
          Object.keys(localStorage)
            .filter((k) => k.startsWith("subs_") && k !== `subs_${id}`)
            .forEach((k) => localStorage.removeItem(k));
        }

        function renderSubtitles() {
          subtitlesList.innerHTML = playerSubtitles
            .map(
              (s, i) => `
              <div class="subtitleItem" id="sub-${i}">
                  <button class="seekButton" onclick="seekTo(${
                    s.start
                  })">â–¶</button>
                <span class="subtitleTime">${fmt(s.start)} - ${fmt(
                s.end
              )}</span>
                <input class="subtitleInput"
                  value="${s.text}"
                  placeholder="${s.placeholder}"
                  onfocus="focusSubtitle(${i})"
                  onblur="stopEditing()"
                  oninput="updateSubtitle(${i}, this.value)">
              </div>`
            )
            .join("");
        }

        function renderSaves() {
          const state = lastGameState;
          if (!state?.video?.id) {
            savesList.innerHTML = "";
            return;
          }

          const key = savesKey(state.video.id);
          const cached = localStorage.getItem(key)
            ? localStorage.getItem(key)
            : null;

          const saves = cached ? JSON.parse(cached) : [];

          if (!saves.length) {
            savesList.innerHTML = "<em>Aucune sauvegarde pour cette vidÃ©o</em>";
            return;
          }

          savesList.innerHTML = saves
            .map(
              (s) => `
        <div class="saveItem">
          <span>${s.name}</span>
          <div>
            <button onclick="loadSave('${s.id}')">ğŸ”„</button>
            <button onclick="deleteSave('${s.id}')">âŒ</button>
          </div>
        </div>
      `
            )
            .join("");
        }

        const renderLocalOverlay = () => {
          const t = video.currentTime;
          const active = playerSubtitles.find(
            (s) => t >= s.start && t <= s.end
          );

          // Overlay local
          subtitlesList
            .querySelectorAll(".subtitleItem")
            .forEach((el, i) =>
              el.classList.toggle("active", playerSubtitles[i] === active)
            );

          if (active && !isRemoteVisible) {
            subtitleOverlayLocal.textContent =
              active.text || active.placeholder;
            subtitleOverlayLocal.style.display = "block";
            if (!isEditingSubtitle)
              scrollToSub(playerSubtitles.indexOf(active));
          } else subtitleOverlayLocal.style.display = "none";
        };

        const updateHeight = () => {
          const newHeight = window.innerHeight;

          const videoHeight = videoContainer.getBoundingClientRect().height;
          const subtitleFormHeight =
            subtitleForm.getBoundingClientRect().height;
          const viewHeight = newHeight - videoHeight - subtitleFormHeight;
          playerView.style.height = `${viewHeight}px`;
          remoteView.style.height = `${viewHeight}px`;
        };

        const toggleView = () => {
          isRemoteVisible = !isRemoteVisible;
          subtitleOverlayLocal.style.display = isRemoteVisible
            ? "none"
            : "block";
          subtitleOverlayRemote.style.display = isRemoteVisible
            ? "block"
            : "none";
          playerView.style.display = isRemoteVisible ? "none" : "block";
          remoteView.style.display = isRemoteVisible ? "block" : "none";
          toggleViewBtn.textContent = isRemoteVisible ? "âœ" : "ğŸ‘‹";

          video.controls = !isRemoteVisible;
          video.pause();

          if (isRemoteVisible) socket.emit("needGameState");

          requestAnimationFrame(() => updateHeight());
        };

        let resizeTimeout;
        let lastHeight = window.innerHeight;
        let currentSubtitleIndex = null;

        requestAnimationFrame(() => updateHeight());

        window.addEventListener("resize", () => {
          const newHeight = window.innerHeight;

          updateHeight();

          clearTimeout(resizeTimeout);

          // On attend que la hauteur se stabilise
          resizeTimeout = setTimeout(() => {
            if (newHeight === lastHeight) {
              // Ici tu peux scroll vers la subtitle active
              scrollToSub(currentSubtitleIndex, 400, false);
            } else if (newHeight > lastHeight) {
              showAllSubtitles();
            }
            lastHeight = newHeight;
          }, 50); // 50ms aprÃ¨s le dernier resize, la hauteur est stabilisÃ©e
        });

        window.loadSave = (saveId) => {
          if (!lastGameState?.video?.id) return;

          const key = savesKey(lastGameState.video.id);
          const cached = localStorage.getItem(key)
            ? localStorage.getItem(key)
            : null;

          const saves = cached ? JSON.parse(cached) : [];

          const save = saves.find((s) => s.id === saveId);
          if (!save) return;

          // âš ï¸ LOCAL UNIQUEMENT
          playerSubtitles = structuredClone(save.subtitles);

          // persistance locale
          localStorage.setItem(
            `subs_${lastGameState.video.id}`,
            JSON.stringify(playerSubtitles)
          );

          // ğŸ” rÃ©hydrater complÃ¨tement lâ€™UI
          renderSubtitles();

          // forcer recalcul overlay / active subtitle / scroll
          video.dispatchEvent(new Event("timeupdate"));
        };

        window.deleteSave = (id) => {
          const { video, selectedPlayerId } = lastGameState;
          const key = savesKey(video.id);
          const saves = JSON.parse(localStorage.getItem(key) || "[]");

          localStorage.setItem(
            key,
            JSON.stringify(saves.filter((s) => s.id !== id))
          );

          renderSaves();
        };

        window.focusSubtitle = (i) => {
          isEditingSubtitle = true;
          video.pause();
          seekTo(playerSubtitles[i].start);

          if (!isMobile()) return;
          hideOtherSubtitles(i);
          currentSubtitleIndex = i;
        };
        window.stopEditing = () => {
          isEditingSubtitle = false;
          showAllSubtitles();
        };
        function hideOtherSubtitles(i) {
          document
            .querySelectorAll(".subtitleItem")
            .forEach((el, j) => (el.style.display = j === i ? "flex" : "none"));
        }
        function showAllSubtitles() {
          document
            .querySelectorAll(".subtitleItem")
            .forEach((el) => (el.style.display = "flex"));
        }
        function scrollToSub(i, duration = 0, smooth = true) {
          const callback = () =>
            document.getElementById(`sub-${i}`)?.scrollIntoView({
              behavior: smooth ? "smooth" : "instant",
              block: "end",
            });
          if (duration === 0) callback();
          setTimeout(callback, duration);
        }
        window.updateSubtitle = (i, text) => {
          playerSubtitles[i].text = text;
          localStorage.setItem(
            `subs_${currentVideoId}`,
            JSON.stringify(playerSubtitles)
          );
          renderLocalOverlay();
        };
        window.seekTo = (t) => {
          video.currentTime = Math.min(video.duration, t + 0.01);
        };

        video.addEventListener("timeupdate", () => {
          // Overlay remote
          if (isRemoteVisible) renderRemoteSubtitles();
          else renderLocalOverlay();
        });

        submitButton.onclick = () => {
          submitSubtitles();
          if (!isRemoteVisible) toggleView();
        };

        /* ================= REMOTE VIDEO ================= */
        async function applyRemoteVideoState(videoState, videoCfg) {
          if (lastAppliedVideoState.id !== videoState.id) {
            applyingRemoteChange = true;
            video.src = videoCfg.path;
            applyingRemoteChange = false;
          }
          if (
            videoState.duration > 0 &&
            videoState.time >= videoState.duration
          ) {
            applyingRemoteChange = true;
            video.pause();
            video.currentTime = videoState.duration;
            applyingRemoteChange = false;
            return;
          }

          if (videoState.playing && video.paused) {
            applyingRemoteChange = true;
            video.play().catch(() => {});
            applyingRemoteChange = false;
          }
          if (!videoState.playing && !video.paused) {
            applyingRemoteChange = true;
            video.pause();
            applyingRemoteChange = false;
          }
          if (Math.abs(video.currentTime - videoState.time) > 1) {
            applyingRemoteChange = true;
            video.currentTime = videoState.time;
            applyingRemoteChange = false;
          }
          lastAppliedVideoState = { ...videoState };
        }

        function renderRemoteSubtitles() {
          if (!lastGameState) return;
          const t = video.currentTime;
          const {
            selectedPlayerId,
            players,
            video: videoState,
          } = lastGameState;
          const videoCfg = videosById[videoState.id];
          let activeSub = null;
          if (selectedPlayerId && players[selectedPlayerId])
            activeSub = players[selectedPlayerId].subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
          if (!activeSub && videoCfg?.subtitles) {
            const placeholder = videoCfg.subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
            if (placeholder) activeSub = { text: placeholder.placeholder };
          }
          if (activeSub) {
            subtitleOverlayRemote.textContent =
              activeSub.text != "" ? activeSub.text : activeSub.placeholder;
            subtitleOverlayRemote.style.display = "block";
          } else subtitleOverlayRemote.style.display = "none";
        }

        /* ================= SOCKET GAMESTATE ================= */

        socket.on("gameState", async (state) => {
          saveButton.disabled = !state?.selectedPlayerId;
          downloadButton.disabled =
            !state?.selectedPlayerId ||
            !state.players[state.selectedPlayerId]?.submitted;

          const videoCfg = videosById[state.video.id];
          if (!videoCfg) return;

          const remoteDuration = state.video.duration;
          lastGameState = state;

          if (currentVideoId !== state.video.id) {
            currentVideoId = state.video.id;
            loadLocalVideo(videoCfg);
            renderSaves();
          }

          // appliquer la remote video seulement si on est en remote view
          if (isRemoteVisible) {
            await applyRemoteVideoState(state.video, videoCfg);
          }

          renderPlayers(state);
          renderVideoSelect(state.video.id);
        });

        socket.on("gameState", (state) => {
          if (!isRemoteVisible) return;
          const videoState = state.video;

          // Synchronisation vidÃ©o
          if (Math.abs(video.currentTime - videoState.time) > 1) {
            applyingRemoteChange = true;
            video.currentTime = videoState.time;
            applyingRemoteChange = false;
          }

          if (videoState.playing && video.paused) video.play();
          if (!videoState.playing && !video.paused) video.pause();
        });

        videoSelect.onchange = () => {
          if (videoSelect.value)
            socket.emit("selectVideoById", videoSelect.value);
        };

        function renderPlayers(state) {
          playersList.innerHTML = Object.entries(state.players)
            .map(
              ([id, p]) =>
                `<div class="playerItem ${p.submitted ? "submitted" : ""} ${
                  state.selectedPlayerId === id ? "selected" : ""
                }" onclick="selectPlayer('${id}')"><span>${
                  p.name
                }</span><span>${p.submitHasBeenPlayed ? "" : "ğŸ“¬"}</span>
                </span><span>${p.submitted ? "âœ…" : "âŒ"}</span></div>`
            )
            .join("");
        }
        window.selectPlayer = (id) => socket.emit("selectPlayer", id);
        function renderVideoSelect(activeId) {
          videoSelect.innerHTML =
            `<option value="">SÃ©lectionner une vidÃ©o</option>` +
            Object.values(videosById)
              .map(
                (v) =>
                  `<option value="${v.id}" ${
                    v.id === activeId ? "selected" : ""
                  }>${v.title || v.id}</option>`
              )
              .join("");
        }

        /* ================= TOGGLE VIEW ================= */
        toggleViewBtn.onclick = toggleView;
        /* ================= SAVE BUTTON ================= */
        let saveTriggered = false;

        const saveSubtitles = () => {
          if (saveTriggered) return; // empÃªche double trigger
          saveTriggered = true;

          try {
            const name = saveNameInput.value.trim();
            if (!name || !lastGameState) {
              saveButton.textContent = "âŒ Nom invalide";
              setTimeout(() => {
                saveButton.textContent = "ğŸ’¾";
                saveTriggered = false;
              }, 1000);
              return;
            }

            const { selectedPlayerId, players, video } = lastGameState;
            if (!selectedPlayerId || !players[selectedPlayerId]) {
              saveButton.textContent = "âŒ Pas de joueur selectionnÃ©";
              setTimeout(() => {
                saveButton.textContent = "ğŸ’¾";
                saveTriggered = false;
              }, 1000);
              return;
            }

            const subtitles = players[selectedPlayerId].subtitles;
            if (!subtitles || !subtitles.length) {
              saveButton.textContent = "âŒ Pas de sous-titres";
              setTimeout(() => {
                saveButton.textContent = "ğŸ’¾";
                saveTriggered = false;
              }, 1000);
              return;
            }

            const key = savesKey(video.id);

            const cached = localStorage.getItem(key)
              ? localStorage.getItem(key)
              : null;

            const saves = cached ? JSON.parse(cached) : [];

            saves.push({
              id: Date.now().toString(),
              name,
              date: Date.now(),
              subtitles,
            });

            try {
              localStorage.setItem(key, JSON.stringify(saves));
            } catch (e) {
              saveButton.textContent = "âŒ Local storage full";
              setTimeout(() => {
                saveButton.textContent = "ğŸ’¾";
                saveTriggered = false;
              }, 1000);
              return;
            }

            renderSaves();

            saveButton.textContent = "âœ… ğŸ’¾";
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾";
              saveTriggered = false;
            }, 1000);
          } catch (e) {
            console.error(e);
            saveButton.textContent = "âŒ " + e.message;
          } finally {
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾";
              saveTriggered = false;
            }, 1000);
          }
        };

        // dÃ©clenchement unique pour click/touch
        saveButton.addEventListener("click", saveSubtitles);

        downloadButton.onclick = () => {
          downloadButton.textContent = "âŒ›";
          fetch("/render")
            .then((r) => r.json())
            .then((data) => {
              if (data.url) {
                // CrÃ©er un lien temporaire pour dÃ©clencher le tÃ©lÃ©chargement
                const a = document.createElement("a");
                a.href = data.url;
                a.download = "video_with_subtitles.mp4"; // Tu peux personnaliser le nom du fichier ici
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(data.url);
                downloadButton.textContent = "â¬‡ï¸";
              }
            })
            .catch((error) => {
              console.error(
                "Erreur lors de la rÃ©cupÃ©ration du fichier:",
                error
              );
            });
        };

        /* ================= CLEAR BUTTON ================= */
        clearButton.onclick = () => {
          if (!confirm("Changez de nom ?")) return;
          localStorage.setItem("playerName", "");
          window.location.reload();
        };
      }

      function fmt(sec) {
        const d = new Date(0);
        d.setSeconds(sec);
        return d.toISOString().substr(11, 8);
      }
      main();
    </script>
  </body>
</html>
