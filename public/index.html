<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>client</title>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <!-- ================= VIDEO ================= -->
    <div id="videoContainer">
      <div id="viewInfo">âœ</div>
      <video id="gameVideo" controls playsinline></video>
      <video id="libraryVideo" controls style="display: none"></video>
      <div id="subtitleOverlayLocal" class="subtitleOverlay"></div>
      <div
        id="subtitleOverlayRemote"
        class="subtitleOverlay"
        style="display: none"
      ></div>
    </div>

    <!-- ================= PLAYER VIEW ================= -->
    <div id="playerView" class="viewContainer">
      <div id="subtitlesList"></div>
    </div>

    <!-- ================= REMOTE VIEW ================= -->
    <div
      id="remoteView"
      class="viewContainer"
      style="display: none; gap: 16px; max-width: 100vw"
    >
      <div style="display: flex; width: 100%; height: 80%">
        <!-- Colonne gauche -->
        <div
          style="
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 70%;
          "
        >
          <div style="display: flex; justify-content: space-between">
            <input
              id="saveNameInput"
              placeholder="Nom de la sauvegarde"
              value="sous-titres"
              style="display: none; max-width: 80%"
            />
            <button id="saveButton" disabled style="display: none">ğŸ’¾</button>
          </div>
          <div id=""></div>
          <div
            id="playersList"
            style="display: block; width: 100%; overflow-y: auto"
          ></div>
        </div>

        <!-- Colonne droite -->
        <div
          style="
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 0;
          "
        >
          <div
            id="savesList"
            style="display: block; width: 100%; overflow-y: auto"
          ></div>
        </div>

        <!-- RemoteView Timeline Container -->
      </div>
      <div
        id="timelineContainer"
        style="
          display: flex;
          overflow-x: auto;
          gap: 4px;
          padding: 4px;
          border: 1px solid #454545;
          height: 20%;
          background-color: #d9d9d9;
        "
      ></div>
    </div>

    <!-- ================= LIBRARY VIEW ================= -->
    <div id="libraryView" class="viewContainer" style="display: none">
      <div class="libraryLayout">
        <select id="librarySelect"></select>

        <div class="libraryEditor">
          <div>
            <label for="startClipInput">â²</label>
            <input
              id="startClipInput"
              type="text"
              required
              placeholder="00:00:00"
              pattern="^([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)$"
              title="Format attendu : hh:mm:ss"
            />
          </div>

          <div>
            <label for="endClipInput">â²</label>
            <input
              id="endClipInput"
              type="text"
              required
              placeholder="00:00:00"
              pattern="^([0-1]\d|2[0-3]):([0-5]\d):([0-5]\d)$"
              title="Format attendu : hh:mm:ss"
            />
          </div>

          <input
            id="clipName"
            required
            placeholder="Nom du clip"
            pattern=".*\S.*"
            title="Le nom du clip ne peut pas Ãªtre vide"
          />
          <button id="createClip">ğŸ’¾</button>
        </div>
      </div>
    </div>

    <!-- ================= FOOTER ================= -->
    <div id="subtitleForm">
      <div class="row">
        <div id="viewActionMenu" class="action-menu">
          <button class="action-menu-toggle">âš™ï¸</button>

          <div class="action-menu-panel">
            <button class="action-menu-item" data-action="libraryView">
              ğŸ“š
            </button>
            <button class="action-menu-item" data-action="remoteView">
              ğŸ¤
            </button>
            <button class="action-menu-item" data-action="playerView">
              âœ
            </button>
          </div>
        </div>

        <span id="playerName"></span>

        <div style="display: inline-flex; align-items: center; gap: 4px">
          <span id="clipLabel" style="cursor: inherit">ğŸ“š</span>
          <select id="clipSelect" style="width: 150px"></select>
          <select id="libraryClipSelect" style="display: none"></select>
        </div>

        <button id="deleteClipButton" style="display: none">âŒ</button>
        <button id="submitButton">ğŸ“„</button>

        <div id="emoticonActionMenu" class="action-menu" style="display: none">
          <button class="action-menu-toggle">ğŸ’¬</button>

          <div class="action-menu-panel">
            <button class="action-menu-item" data-action="emoticon">ğŸ˜•</button>
            <!-- dÃ©routant -->
            <button class="action-menu-item" data-action="emoticon">ğŸ˜</button>
            <!-- neutre / moyen -->
            <button class="action-menu-item" data-action="emoticon">ğŸ˜¬</button>
            <!-- maladroit / gÃªnant -->

            <button class="action-menu-item" data-action="emoticon">ğŸ™‚</button>
            <!-- agrÃ©able -->
            <button class="action-menu-item" data-action="emoticon">ğŸ˜‚</button>
            <!-- fonctionne trÃ¨s bien -->

            <button class="action-menu-item" data-action="emoticon">â—</button>
            <!-- choque / faux -->
            <button class="action-menu-item" data-action="emoticon">â“</button>
            <!-- pas clair -->

            <button class="action-menu-item" data-action="emoticon">ğŸ‘</button>
            <!-- ok -->
            <button class="action-menu-item" data-action="emoticon">ğŸ‘</button>
            <!-- pas ok -->
          </div>
        </div>

        <button id="renderButton" disabled style="display: none">ğŸ“½ï¸</button>
        <button id="goToRender" disabled style="display: none">ğŸï¸</button>
      </div>
    </div>

    <script>
      async function main() {
        /* ================= DOM ================= */
        const viewInfo = document.getElementById("viewInfo");
        const gameVideo = document.getElementById("gameVideo");
        const libraryVideo = document.getElementById("libraryVideo");
        const subtitleOverlayLocal = document.getElementById(
          "subtitleOverlayLocal"
        );

        const videoContainer = document.getElementById("videoContainer");
        const subtitleOverlayRemote = document.getElementById(
          "subtitleOverlayRemote"
        );
        const subtitlesList = document.getElementById("subtitlesList");

        const subtitleForm = document.getElementById("subtitleForm");
        const submitButton = document.getElementById("submitButton");

        const saveButton = document.getElementById("saveButton");
        const saveNameInput = document.getElementById("saveNameInput");

        const emoticonActionMenu =
          document.getElementById("emoticonActionMenu");

        const playerNameSpan = document.getElementById("playerName");

        const playerView = document.getElementById("playerView");
        const remoteView = document.getElementById("remoteView");
        const libraryView = document.getElementById("libraryView");
        const clipLabel = document.getElementById("clipLabel");
        const librarySelect = document.getElementById("librarySelect");
        const libraryClipSelect = document.getElementById("libraryClipSelect");
        const deleteClipButton = document.getElementById("deleteClipButton");

        const renderButton = document.getElementById("renderButton");
        const goToRender = document.getElementById("goToRender");

        const clipSelect = document.getElementById("clipSelect");
        const playersList = document.getElementById("playersList");
        const savesList = document.getElementById("savesList");

        /* ================= STATE ================= */
        let videosById = {};
        let libraryVideosById = {};
        let currentViewId = "playerView";
        let playerSubtitles = [];
        let currentVideoId = null;
        let isEditingSubtitle = false;
        let isRemoteVisible = false;
        let applyingRemoteChange = false;
        let lastAppliedVideoState = { id: null, playing: null, time: null };
        let lastGameState = null;

        function savesKey(videoId) {
          return `savedSubs_${videoId}`;
        }

        function isMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        }

        /* ================= PLAYER NAME ================= */
        let playerName = localStorage.getItem("playerName");
        if (!playerName) {
          playerName = prompt(
            "Quel est ton pseudo ?",
            "Joueur " + Math.floor(Math.random() * 1000)
          );
          localStorage.setItem("playerName", playerName);
        }
        playerNameSpan.textContent = "ğŸ¤– " + playerName;

        /* ================= CONFIG ================= */
        const cfg = await fetch("/config.json").then((r) => r.json());
        videosById = Object.fromEntries(cfg.videos.map((v) => [v.id, v]));
        libraryVideosById = Object.fromEntries(
          cfg.library_videos.map((v) => [v.id, v])
        );

        /* ================= SOCKET ================= */
        const socket = io({ reconnection: true, timeout: 20000 });
        socket.on("connect", () =>
          socket.emit("register", { role: "player", playerName })
        );

        socket.on("reload", () => location.reload());

        /* ================= INIT DISPLAY ================= */
        gameVideo.style.display = "block";
        subtitleOverlayLocal.style.display = "block";
        subtitleOverlayRemote.style.display = "none";
        playerView.style.display = "block";
        remoteView.style.display = "none";

        const submitSubtitles = () => {
          if (
            playerSubtitles.length === 0 ||
            playerSubtitles.every((s) => !s.text || s.text === "")
          )
            return false;

          socket.emit(
            "submitSubtitles",
            playerSubtitles.map((s) => ({
              start: s.start,
              end: s.end,
              text: s.text || "",
              placeholder: s.placeholder,
            }))
          );

          return true;
        };

        /* ================= LOCAL VIDEO ================= */
        function loadLocalVideo(state, videoCfg) {
          gameVideo.src = videoCfg.path;
          gameVideo.load();
          const cached = localStorage.getItem(`subs_${videoCfg.id}`);

          playerSubtitles = null;

          for (let key in state.players) {
            if (playerName === state.players[key].name) {
              playerSubtitles = state.players[key].subtitles;
              break;
            }
          }

          if (cached) {
            const subtitlesCached = JSON.parse(cached);
            playerSubtitles = playerSubtitles.map((s, index) => {
              return {
                ...s,
                text: subtitlesCached[index] ? subtitlesCached[index].text : "",
              };
            });
          }

          localStorage.setItem(
            `subs_${currentVideoId}`,
            JSON.stringify(playerSubtitles.map((s) => ({ text: s.text })))
          );
          cleanupOtherCaches(videoCfg.id);
          renderSubtitles();
        }

        function cleanupOtherCaches(id) {
          Object.keys(localStorage)
            .filter((k) => k.startsWith("subs_") && k !== `subs_${id}`)
            .forEach((k) => localStorage.removeItem(k));
        }

        function renderSubtitles() {
          subtitlesList.innerHTML = playerSubtitles
            .map(
              (s, i) => `
                                <div class="subtitleItem" id="sub-${i}">
                                    <button class="seekButton" onclick="seekTo(${
                                      s.start
                                    })">â–¶</button>
                                  <span class="subtitleTime">${fmt(
                                    s.start
                                  )} - ${fmt(s.end)}</span>
                                  <input class="subtitleInput"
                                    value="${s.text ? s.text : ""}"
                                    placeholder="${s.placeholder}"
                                    onfocus="focusSubtitle(${i})"
                                    onblur="stopEditing()"
                                    oninput="updateSubtitle(${i}, this.value)">
                                </div>`
            )
            .join("");
        }

        function renderSaves() {
          const state = lastGameState;
          if (!state?.video?.id) {
            savesList.innerHTML = "";
            return;
          }

          const saves =
            (state.clipSaves && state.clipSaves[state.video.id]) || [];
          if (!saves.length) {
            savesList.innerHTML = "<em>Aucun sous-titre pour ce clip</em>";
            return;
          }

          savesList.innerHTML = saves
            .map((s, index) => {
              return `
        <div class="saveItem" style="display:flex; justify-content:space-between; align-items:center;">
          <span>${s.name}</span>
          <div>
            <button onclick="loadSave(${index})">âœ</button>
            <button onclick="deleteSave(${index})">âŒ</button>
            <button onclick="selectClipToInsert('${state.video.id}', ${index})">â•</button>
          </div>
        </div>
      `;
            })
            .join("");
        }

        const renderLocalOverlay = () => {
          const t = gameVideo.currentTime;
          const active = playerSubtitles.find(
            (s) => t >= s.start && t <= s.end
          );

          // Overlay local
          subtitlesList
            .querySelectorAll(".subtitleItem")
            .forEach((el, i) =>
              el.classList.toggle("active", playerSubtitles[i] === active)
            );

          if (active && !isRemoteVisible) {
            subtitleOverlayLocal.textContent =
              active.text || active.placeholder;
            subtitleOverlayLocal.style.display = "block";
            if (!isEditingSubtitle)
              scrollToSub(playerSubtitles.indexOf(active));
          } else subtitleOverlayLocal.style.display = "none";
        };

        const updateHeight = () => {
          const newHeight = window.innerHeight;

          const videoHeight = videoContainer.getBoundingClientRect().height;
          const subtitleFormHeight =
            subtitleForm.getBoundingClientRect().height;
          const viewHeight = newHeight - videoHeight - subtitleFormHeight;
          playerView.style.height = `${viewHeight}px`;
          remoteView.style.height = `${viewHeight}px`;
        };

        const displayView = (id) => {
          if (id === currentViewId) return;

          currentViewId = id;

          viewInfo.textContent =
            id === "playerView" ? "âœ" : id === "remoteView" ? "ğŸ¤" : "ğŸ“š";

          localStorage.setItem("currentViewId", currentViewId);
          playerView.style.display = id === "playerView" ? "block" : "none";
          remoteView.style.display = id === "remoteView" ? "block" : "none";
          libraryView.style.display = id === "libraryView" ? "block" : "none";

          gameVideo.style.display =
            id === "playerView" || id === "remoteView" ? "block" : "none";
          libraryVideo.style.display = id === "libraryView" ? "block" : "none";

          if (id === "playerView" || id === "remoteView") {
            socket.emit("needGameState");
          } else {
            libraryVideo.src = libraryVideosById[librarySelect.value].path;
          }

          libraryClipSelect.style.display =
            id === "libraryView" ? "block" : "none";

          deleteClipButton.style.display =
            id === "libraryView" ? "block" : "none";

          submitButton.style.display = id === "playerView" ? "block" : "none";

          clipSelect.style.display =
            id === "playerView" || id === "remoteView" ? "block" : "none";

          renderButton.style.display = id === "remoteView" ? "block" : "none";
          goToRender.style.display = id === "remoteView" ? "block" : "none";

          isRemoteVisible = id === "remoteView";

          subtitleOverlayLocal.style.display =
            id === "playerView" ? "block" : "none";
          subtitleOverlayRemote.style.display = isRemoteVisible
            ? "block"
            : "none";

          saveButton.style.display = !isRemoteVisible ? "none" : "block";
          saveNameInput.style.display = !isRemoteVisible ? "none" : "block";
          emoticonActionMenu.style.display = isRemoteVisible ? "block" : "none";
          gameVideo.controls = !isRemoteVisible;
          gameVideo.pause();

          libraryVideo.pause();

          requestAnimationFrame(() => updateHeight());
        };

        let resizeTimeout;
        let lastHeight = window.innerHeight;
        let currentSubtitleIndex = null;

        window.addEventListener("resize", () => {
          const newHeight = window.innerHeight;

          updateHeight();

          clearTimeout(resizeTimeout);

          // On attend que la hauteur se stabilise
          resizeTimeout = setTimeout(() => {
            if (newHeight === lastHeight) {
              // Ici tu peux scroll vers la subtitle active
              scrollToSub(currentSubtitleIndex, 400, false);
            } else if (newHeight > lastHeight) {
              showAllSubtitles();
            }
            lastHeight = newHeight;
          }, 50); // 50ms aprÃ¨s le dernier resize, la hauteur est stabilisÃ©e
        });

        window.loadSave = (index) => {
          if (!lastGameState?.video?.id) return;

          const saves =
            (lastGameState.clipSaves &&
              lastGameState.clipSaves[lastGameState.video.id]) ||
            [];
          const save = saves[index];
          if (!save) return;

          // âš¡ Copier les sous-titres dans playerSubtitles
          playerSubtitles = structuredClone(save.subtitles);

          // RÃ©hydrater complÃ¨tement lâ€™UI
          renderSubtitles();

          // Forcer recalcul overlay / scroll
          gameVideo.dispatchEvent(new Event("timeupdate"));

          // Afficher playerView
          displayView("playerView");
        };

        window.deleteSave = (index) => {
          if (!lastGameState?.video?.id) return;

          const videoId = lastGameState.video.id;

          // ğŸ”¹ Demande serveur pour supprimer le save
          socket.emit("deleteClipSave", { videoId, index });
        };

        window.focusSubtitle = (i) => {
          isEditingSubtitle = true;
          gameVideo.pause();
          seekTo(playerSubtitles[i].start);

          if (!isMobile()) return;
          hideOtherSubtitles(i);
          currentSubtitleIndex = i;
        };
        window.stopEditing = () => {
          isEditingSubtitle = false;
          showAllSubtitles();
        };
        function hideOtherSubtitles(i) {
          document
            .querySelectorAll(".subtitleItem")
            .forEach(
              (el, j) => (el.style.display = j >= i - 1 ? "flex" : "none")
            );
        }
        function showAllSubtitles() {
          document
            .querySelectorAll(".subtitleItem")
            .forEach((el) => (el.style.display = "flex"));
        }
        function scrollToSub(i, duration = 0, smooth = true) {
          const callback = () =>
            document.getElementById(`sub-${i}`)?.scrollIntoView({
              behavior: smooth ? "smooth" : "instant",
              block: "end",
            });
          if (duration === 0) callback();
          setTimeout(callback, duration);
        }
        window.updateSubtitle = (i, text) => {
          playerSubtitles[i].text = text;
          localStorage.setItem(
            `subs_${currentVideoId}`,
            JSON.stringify(playerSubtitles)
          );
          renderLocalOverlay();
        };
        window.seekTo = (t) => {
          gameVideo.currentTime = Math.min(gameVideo.duration, t + 0.01);
        };

        gameVideo.addEventListener("timeupdate", () => {
          // Overlay remote
          if (isRemoteVisible) renderRemoteSubtitles();
          else renderLocalOverlay();
        });

        submitButton.onclick = () => {
          const success = submitSubtitles();
          if (success && !isRemoteVisible) {
            displayView("remoteView");
          }

          submitButton.textContent = success ? "âœ…" : "âŒ";
          setTimeout(() => (submitButton.textContent = "ğŸ“„"), 1000);
        };

        /* ================= REMOTE VIDEO ================= */
        async function applyRemoteVideoState(videoState, videoCfg) {
          if (lastAppliedVideoState.id !== videoState.id) {
            applyingRemoteChange = true;
            gameVideo.src = videoCfg.path;
            applyingRemoteChange = false;
          }

          if (videoState.playing && gameVideo.paused) {
            applyingRemoteChange = true;
            gameVideo.play().catch(() => {});
            applyingRemoteChange = false;
          }
          if (!videoState.playing && !gameVideo.paused) {
            applyingRemoteChange = true;
            gameVideo.pause();
            applyingRemoteChange = false;
          }
          if (Math.abs(gameVideo.currentTime - videoState.time) > 1) {
            applyingRemoteChange = true;
            gameVideo.currentTime = videoState.time;
            applyingRemoteChange = false;
          }
          lastAppliedVideoState = { ...videoState };
        }

        function renderRemoteSubtitles() {
          if (!lastGameState) return;
          const t = gameVideo.currentTime;
          const {
            selectedPlayerId,
            players,
            video: videoState,
          } = lastGameState;
          const videoCfg = videosById[videoState.id];
          let activeSub = null;
          if (selectedPlayerId && players[selectedPlayerId])
            activeSub = players[selectedPlayerId].subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
          if (!activeSub && videoCfg?.subtitles) {
            const placeholder = videoCfg.subtitles.find(
              (s) => t >= s.start && t <= s.end
            );
            if (placeholder) activeSub = { text: placeholder.placeholder };
          }
          if (activeSub) {
            subtitleOverlayRemote.textContent = activeSub.text
              ? activeSub.text
              : activeSub.placeholder;
            subtitleOverlayRemote.style.display = "block";
          } else subtitleOverlayRemote.style.display = "none";
        }

        /* ================= TIMELINE ================= */

        let selectedClipToInsert = null; // clip choisi pour insertion
        let timelineClips = []; // clips actuellement dans la timeline

        // SÃ©lection d'un clip depuis la liste des saves
        window.selectClipToInsert = function selectClipToInsert(
          videoId,
          saveIndex
        ) {
          const saves = lastGameState.clipSaves?.[videoId] || [];
          const clip = saves[saveIndex];
          if (!clip) return;
          selectedClipToInsert = { videoId, ...clip, index: saveIndex };
          renderTimeline();
        };

        // Render timeline avec slots â• uniquement si un clip est sÃ©lectionnÃ©
        function renderTimeline() {
          const container = document.getElementById("timelineContainer");
          container.innerHTML = "";

          const showSlots = !!selectedClipToInsert;

          // Slot initial
          if (showSlots) addSlot(0);

          timelineClips.forEach((clip, i) => {
            const div = document.createElement("div");
            div.className = "timelineClipItem";
            div.textContent = clip.videoId + " - " + clip.name;

            // bouton delete
            const delBtn = document.createElement("button");
            delBtn.textContent = "âŒ";
            delBtn.style.marginTop = "4px";
            delBtn.onclick = (e) => {
              e.stopPropagation();
              timelineClips.splice(i, 1);
              renderTimeline();
              socket.emit("updateTimeline", timelineClips);
            };
            div.appendChild(delBtn);

            container.appendChild(div);

            // slot aprÃ¨s le clip
            if (showSlots) addSlot(i + 1);
          });

          // helper pour crÃ©er un slot
          function addSlot(position) {
            const slot = document.createElement("button");
            slot.textContent = "â•";
            slot.onclick = () => {
              if (!selectedClipToInsert) return;
              timelineClips.splice(position, 0, { ...selectedClipToInsert });
              selectedClipToInsert = null; // dÃ©sÃ©lection
              renderTimeline();
              socket.emit("updateTimeline", timelineClips);
            };
            container.appendChild(slot);
          }
        }

        function insertClip(index) {
          if (!selectedClipToInsert) return;

          // timelineClips est ton tableau global de la timeline
          timelineClips.splice(index + 1, 0, { ...selectedClipToInsert });
          selectedClipToInsert = null; // dÃ©sÃ©lection
          renderTimeline();
          socket.emit("updateTimeline", timelineClips);
        }

        submitButton.addEventListener("animationend", () => {
          submitButton.textContent = "ğŸ“„";
        });

        /* ================= SOCKET GAMESTATE ================= */
        let currentEmoticons = {};
        socket.on("gameState", async (state) => {
          lastGameState = state;

          const videoCfg = videosById[state.video.id];

          if (currentVideoId !== state.video.id) {
            currentVideoId = state.video.id;
            loadLocalVideo(state, videoCfg);
          }

          renderClipSelect(state.video.id);

          if (currentViewId == "playerView" && state.receivedSubtitles) {
            submitButton.classList.remove("pulse-once"); // reset au cas oÃ¹
            void submitButton.offsetWidth; // force reflow
            submitButton.classList.add("pulse-once");
            submitButton.textContent = "ğŸ‘‹";
          }

          // opti

          if (!isRemoteVisible) return;

          renderButton.disabled = state.timeline.length === 0;
          goToRender.disabled = !state.renderUrl;
          if (state.finishRender) {
            goToRender.classList.remove("pulse-once"); // reset au cas oÃ¹
            void goToRender.offsetWidth; // force reflow
            goToRender.classList.add("pulse-once");
          }

          // Reset selectedClipToInsert si clip plus prÃ©sent
          if (selectedClipToInsert) {
            const saves = state.clipSaves?.[selectedClipToInsert.videoId] || [];
            const stillExists = saves.some(
              (s) => s.name === selectedClipToInsert.name
            );
            if (!stillExists) selectedClipToInsert = null;
          }
          timelineClips = state.timeline; // mise Ã  jour

          renderTimeline();
          renderSaves();

          let newEmoticons = {};
          Object.entries(state.emoticons).forEach(([name, text]) => {
            newEmoticons[name] = text;
            if (!currentEmoticons[name]) {
              const createEmoticon = () => {
                const emoticon = document.createElement("div");
                emoticon.className = "emoticon";
                const nameEl = document.createElement("div");
                nameEl.className = "emoticonName";
                nameEl.textContent = name;
                emoticon.appendChild(nameEl);
                const textEl = document.createElement("div");
                textEl.className = "emoticonText";
                textEl.textContent = text;
                emoticon.appendChild(textEl);

                // random position on videoContainer
                const videoRect = gameVideo.getBoundingClientRect();
                const x =
                  videoRect.width * 0.5 +
                  (Math.random() - 0.5) * 2 * videoRect.width * 0.3;
                const y =
                  -Math.random() * videoRect.height * 0.5 + videoRect.bottom;
                emoticon.style.left = `${x}px`;
                emoticon.style.top = `${y}px`;

                document.body.appendChild(emoticon);
                setTimeout(() => {
                  emoticon.remove();
                  currentEmoticons[name] = null;
                }, 3000);
              };
              createEmoticon();
            }
          });
          currentEmoticons = newEmoticons;

          saveButton.disabled =
            !state?.selectedPlayerId ||
            !state.players[state.selectedPlayerId]?.submitted;

          await applyRemoteVideoState(state.video, videoCfg);
          renderPlayers(state);
          const videoState = state.video;

          // Synchronisation vidÃ©o
          if (Math.abs(gameVideo.currentTime - videoState.time) > 1) {
            applyingRemoteChange = true;
            gameVideo.currentTime = videoState.time;
            applyingRemoteChange = false;
          }

          if (videoState.playing && gameVideo.paused) gameVideo.play();
          if (!videoState.playing && !gameVideo.paused) gameVideo.pause();
        });

        const playerState = () => {
          if (!lastGameState) return null;

          const players = Object.values(lastGameState.players);
          for (let i = 0; i < players.length; i++) {
            if (players[i].name == playerName) return players[i];
          }

          return null;
        };

        clipSelect.onchange = () => {
          if (clipSelect.value)
            socket.emit("selectVideoById", clipSelect.value);
        };

        function renderPlayers(state) {
          playersList.innerHTML = Object.entries(state.players)
            .map(
              ([id, p]) =>
                `<div class="playerItem ${p.submitted ? "submitted" : ""} ${
                  state.selectedPlayerId === id ? "selected" : ""
                }" onclick="selectPlayer('${id}')"><span>ğŸ¤–</span><span>${
                  p.submitted ? "ğŸ“„" : "âŒ"
                }</span>
                                  </span><span>${
                                    p.submitHasBeenPlayed ? "" : "ğŸ‘‹"
                                  }</span><span>${p.name}</span>

                                    </div>`
            )
            .join("");
        }
        window.selectPlayer = (id) => socket.emit("selectPlayer", id);
        function renderClipSelect(activeId) {
          clipSelect.innerHTML = "";

          Object.values(videosById)
            .sort((a, b) => a.id.toString().localeCompare(b.id.toString()))
            .forEach((v) => {
              const option = document.createElement("option");
              option.value = v.id;
              option.textContent = `${v.id} (${v.lang})`;

              if (v.id === activeId) {
                option.selected = true;
              }

              clipSelect.appendChild(option);
            });
        }

        function isTemplate(id) {
          return id.startsWith("template-");
        }

        function renderLibraryView() {
          librarySelect.innerHTML = "";

          // Regrouper les vidÃ©os par langue
          const videosByLang = {};
          Object.values(libraryVideosById).forEach((v) => {
            if (!videosByLang[v.lang]) videosByLang[v.lang] = [];
            videosByLang[v.lang].push(v);
          });

          // CrÃ©er les optgroup
          Object.keys(videosByLang)
            .sort() // trier les langues par ordre alphabÃ©tique
            .forEach((lang) => {
              const optgroup = document.createElement("optgroup");
              optgroup.label = lang;

              // trier les vidÃ©os par id dans chaque langue
              videosByLang[lang]
                .sort((a, b) => a.id.toString().localeCompare(b.id.toString()))
                .forEach((v) => {
                  const option = document.createElement("option");
                  option.value = v.id;
                  option.textContent = `${v.id}`;
                  optgroup.appendChild(option);
                });

              librarySelect.appendChild(optgroup);
            });

          libraryClipSelect.innerHTML = "";

          Object.values(videosById)
            .sort((a, b) => a.id.toString().localeCompare(b.id.toString()))
            .forEach((v) => {
              if (isTemplate(v.id)) return;
              const option = document.createElement("option");
              option.value = v.id;
              option.textContent = `${v.id} (${v.lang})`;
              libraryClipSelect.appendChild(option);
            });
        }
        renderLibraryView();

        deleteClipButton.onclick = () => {
          socket.emit("deleteClip", libraryClipSelect.value);
        };

        librarySelect.onchange = () => {
          libraryVideo.src = libraryVideosById[librarySelect.value].path;
        };

        /* ================= SAVE BUTTON ================= */
        let saveTriggered = false;

        const saveSubtitles = () => {
          if (saveTriggered) return; // empÃªche double clic
          saveTriggered = true;

          const name = saveNameInput.value.trim();
          if (!name || !lastGameState) {
            saveButton.textContent = "âŒ Nom invalide";
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾";
              saveTriggered = false;
            }, 1000);
            return;
          }

          const { selectedPlayerId, players, video } = lastGameState;
          if (!selectedPlayerId || !players[selectedPlayerId]) {
            saveButton.textContent = "âŒ";
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾";
              saveTriggered = false;
            }, 1000);
            return;
          }

          const subtitles = players[selectedPlayerId].subtitles;
          if (!subtitles || !subtitles.length) {
            saveButton.textContent = "âŒ";
            setTimeout(() => {
              saveButton.textContent = "ğŸ’¾";
              saveTriggered = false;
            }, 1000);
            return;
          }

          // ğŸ”¹ Envoi via socket au lieu de localStorage
          socket.emit("saveRemoteSubtitles", {
            videoId: video.id,
            name,
            subtitles,
          });

          // Feedback utilisateur
          saveButton.textContent = "âœ…";
          setTimeout(() => {
            saveButton.textContent = "ğŸ’¾";
            saveTriggered = false;
          }, 1000);
        };

        // dÃ©clenchement unique pour click/touch
        saveButton.addEventListener("click", saveSubtitles);

        renderButton.addEventListener("click", () => {
          if (confirm("Etes-vous sur de vouloir lancer un rendu ?"))
            socket.emit("render");
        });
        goToRender.addEventListener("click", () => {
          window.location.href = "/render/final.mp4";
        });

        /* ================= LIBRARY VIEW ================= */

        const startInput = document.getElementById("startClipInput");
        const endInput = document.getElementById("endClipInput");
        const nameInput = document.getElementById("clipName");
        const createBtn = document.getElementById("createClip");

        const seekToInputValue = (input) => {
          if (!input.checkValidity()) return;

          const t = toSeconds(input.value);
          if (Number.isNaN(t)) return;

          libraryVideo.currentTime = t;
        };

        startInput.addEventListener("focus", () => {
          seekToInputValue(startInput);
        });

        startInput.addEventListener("input", () => {
          seekToInputValue(startInput);
        });

        endInput.addEventListener("focus", () => {
          seekToInputValue(endInput);
        });

        endInput.addEventListener("input", () => {
          seekToInputValue(endInput);
        });

        libraryVideo.addEventListener("timeupdate", () => {
          // VÃ©rifie que le champ est valide
          if (!endInput.checkValidity()) return;

          const endSec = toSeconds(endInput.value);
          if (!Number.isFinite(endSec)) return;

          // Si le temps courant dÃ©passe la fin, pause la vidÃ©o
          if (libraryVideo.currentTime >= endSec + 5 && !libraryVideo.paused) {
            libraryVideo.pause();
          }
        });

        let isCreatingClip = false;
        createBtn.addEventListener("click", () => {
          if (isCreatingClip) return;

          // 1. Validation HTML native
          if (!startInput.checkValidity() || !endInput.checkValidity()) {
            // Force lâ€™affichage du message du navigateur
            startInput.reportValidity();
            endInput.reportValidity();
            return;
          }

          // 2. RÃ©cupÃ©ration des valeurs
          const start = startInput.value;
          const end = endInput.value;
          const name = nameInput.value.trim();

          if (!name) {
            alert("Nom du clip obligatoire");
            return;
          }

          const id = normalizeToId(name);

          if (videosById[id]) {
            alert("Un clip porte deja ce nom");
            return;
          }

          // 3. Conversion en secondes
          const startSec = toSeconds(start);
          const endSec = toSeconds(end);

          // 4. VÃ©rifications mÃ©tier
          if (endSec <= startSec) {
            alert("La fin doit Ãªtre aprÃ¨s le dÃ©but");
            return;
          }

          if (endSec - startSec < 5) {
            alert("La durÃ©e minimale est de 5 secondes");
            return;
          }

          if (endSec - startSec > 120) {
            alert("La durÃ©e maximale est de 2 minutes");
            return;
          }

          // 5. Utilisation finale
          createBtn.textContent = "âŒ›";

          isCreatingClip = true;

          socket.emit("createClip", {
            libraryVideoId: librarySelect.value,
            lang: libraryVideosById[librarySelect.value].lang,
            id,
            start,
            end,
          });
        });

        /* ================= CLEAR BUTTON ================= */
        playerNameSpan.onclick = () => {
          if (!confirm("Changez de nom ?")) return;
          localStorage.setItem("playerName", "");
          window.location.reload();
        };

        /* ================= ACTION MENU ================= */
        document.querySelectorAll(".action-menu").forEach((menu) => {
          const toggle = menu.querySelector(".action-menu-toggle");
          const items = menu.querySelectorAll(".action-menu-item");

          toggle.addEventListener("click", (e) => {
            e.stopPropagation();

            // fermer les autres menus
            document
              .querySelectorAll(".action-menu.open")
              .forEach((m) => m !== menu && m.classList.remove("open"));

            menu.classList.toggle("open");
          });

          items.forEach((btn) => {
            btn.addEventListener("click", () => {
              menu.classList.remove("open");

              const action = btn.dataset.action;

              switch (action) {
                case "emoticon":
                  socket.emit("emoticon", {
                    text: btn.textContent,
                    name: playerName,
                  });
                  break;
                case "playerView":
                case "remoteView":
                case "libraryView":
                  displayView(action);
                  break;
              }
            });
          });
        });

        // clic global â†’ fermeture
        document.addEventListener("click", () => {
          document
            .querySelectorAll(".action-menu.open")
            .forEach((m) => m.classList.remove("open"));
        });

        // init from cache
        const cachedViewId = localStorage.getItem("currentViewId");
        if (cachedViewId && cachedViewId !== "playerView") {
          displayView(cachedViewId);
        } else {
          requestAnimationFrame(() => updateHeight());
        }
      }

      function fmt(sec) {
        const d = new Date(0);
        d.setSeconds(sec);
        return d.toISOString().substr(11, 8);
      }
      function toSeconds(hhmmss) {
        const [h, m, s] = hhmmss.split(":").map(Number);
        return h * 3600 + m * 60 + s;
      }
      function normalizeToId(text) {
        return text
          .toString()
          .normalize("NFD") // sÃ©pare accents
          .replace(/[\u0300-\u036f]/g, "") // supprime accents
          .toLowerCase()
          .trim()
          .replace(/[^a-z0-9]+/g, "-") // caractÃ¨res non autorisÃ©s â†’ "-"
          .replace(/^-+|-+$/g, ""); // trim des "-"
      }

      main();
    </script>
  </body>
</html>
